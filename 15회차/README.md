## Algorithm Study 14íšŒì°¨ íšŒì˜ (24.5.12.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 5ì›” 12ì¼ ì¼ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ì†¡ì •ì‚¼ì •ì˜¤í”¼ìŠ¤í…” 2ì¸µ íœ´ê²Œì‹¤

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 6ì›” 1ì¼ ì¼ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ê¹€í•´ ì»¤í”¼íŒ€ë²„

    ë‹¤. ë³€ê²½ì‚¬í•­
        1. íšŒì˜ ì¼ì • ê¸°ë³¸ê°’ì€ ì¼ìš”ì¼ ì˜¤ì „ 9ì‹œ(í˜‘ì˜ í›„ ë³€ë™ë  ìˆ˜ ìˆìŒ)
        2. ìµœì†Œí•œì˜ ê³µë™ëª©í‘œì¸ "ì½”í…Œí•©ê²©"ì„ ê¸°ì›í•˜ê¸° ìœ„í•´ ë¬¸ì œ ìˆ˜ëŠ” ëŠ˜ë¦¬ê³  ë‚œì´ë„ëŠ” ë‚®ì¶”ì–´ ìµœëŒ€í•œ ë‹¤ì–‘í•œ ë¬¸ì œ ì„ ì •
            - ì´ë²ˆ ì£¼ëŠ” ê°ì í•œ ë¬¸ì œë©°, ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œëŠ” ë¼ì´ë¸Œë¡œ ì½”ë”©í•  ê²ƒì´ë‹ˆ, ì‹ ì¤‘íˆ ì„ ì • í•„ìš”
            - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ í™˜ê²½ì—ì„œë„ ë§ì´ ì¹˜ëŠ” ê²ƒì„ ê°ì•ˆí•˜ì—¬ ë°±ì¤€ ì™¸ì— ì‚¬ì´íŠ¸ë„ ì°¸ê³ í•˜ì—¬ ì„ ì • 
        3. ì–´ë ¤ìš´ ë¬¸ì œë¥¼ í•œ ëª…ì”© ì„ ì •.
            - ìˆœì„œ : ì´ë²ˆì£¼ ì´ê¶Œë¯¼ (ì´ìƒí˜„ - ì´ì°½í˜¸ - ì„ê²½íƒœ - ìµœì§€ìš° - ë°•ë™í˜„ - ìœ¤ì˜ˆë¦¬ - ì´ê¶Œë¯¼)
        4. ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        5. ì–´ë ¤ìš´ ë¬¸ì œ ê¸°ì¤€
            - ë°±ì¤€ : ê³¨ë“œ 3 ì´ìƒ
            - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ : Lv.3 ì´ìƒ
            - SWEA : D5 ë˜ëŠ” Aí˜• ì—­ëŸ‰í…ŒìŠ¤íŠ¸ 
            - ì†Œí”„í‹°ì–´ : Lv.3 ì´ìƒ
        
### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ì´ë²ˆ ì£¼ì˜ ì–´ë ¤ìš´ ë¬¸ì œ : kë²ˆì§¸ ìµœë‹¨ê±°ë¦¬
      - ë¬¸ì œ ì„ ì •ìê°€ ë¼ì´ë¸Œ ì½”ë”©í•˜ë©´ì„œ ì†”ë£¨ì…˜ ë¦¬ë·°
      - í‘¼ ë°©ì‹ ì´ì™¸ì—ë„ ë‹¤ì–‘í•œ ë°©ë²• ì œì‹œ

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258707 n+1 ì¹´ë“œê²Œì„(2024 KAKAO WINTER INTERNSHIP, Lv.3) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 2146 ë‹¤ë¦¬ë§Œë“¤ê¸°(ê³¨ë“œ 3) 
   ###### 3. ê²½íƒœ
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 17681 ë¹„ë°€ì§€ë„(2018 KAKAO BLIND RECRUITMENT,Lv.1)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 1854 kë²ˆì§¸ ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°(í”Œë˜í‹°ë„˜ 4)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258711 ë„ë„›ê³¼ ë§‰ëŒ€ ê·¸ë˜í”„(Lv.2)
   ###### 6. ì§€ìš°
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 150368 ì´ëª¨í‹°ì½˜ í• ì¸í–‰ì‚¬(2023 KAKAO BLIND RECRUITMENT Lv.3)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 7579 ì•±(ê³¨ë“œ 3)

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 214289 ì—ì–´ì»¨(2023 í˜„ëŒ€ëª¨ë¹„ìŠ¤ ì•Œê³ ë¦¬ì¦˜ ê²½ì§„ëŒ€íšŒ ì˜ˆì„ , Lv.3) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 1052 ë¬¼ë³‘(ê³¨ë“œ 5) 
   ###### 3. ê²½íƒœ
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 150369 íƒë°° ë°°ë‹¬ê³¼ ìˆ˜ê±°í•˜ê¸° (2023 KAKAO BLIND RECRUITMENT, Lv.2)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 17392 ìš°ìš¸í•œ ë°©í•™(ì‹¤ë²„ 1)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 42888 ì˜¤í”ˆì±„íŒ…ë°© (Lv.2)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 2529 ë¶€ë“±í˜¸ (ì‹¤ë²„ 1)
   ###### 7. ê¶Œë¯¼
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 72411 ë©”ë‰´ ë¦¬ë‰´ì–¼ (2021 KAKAO BLIND RECRUITMENT,Lv.2)

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1854 kë²ˆì§¸ ìµœë‹¨ê²½ë¡œ
> `ë‹¤ìµìŠ¤íŠ¸ë¼` í•¨ìˆ˜ êµ¬í˜„
> ì¼ë°˜ì ìœ¼ë¡œ ë™ì¼í•˜ë‚˜, kë²ˆì§¸ ê²½ë¡œì˜ ë¹„ìš©ì„ ë¹„êµí•˜ì—¬ ë” ì‘ì„ ê²½ìš° ì €ì¥í•˜ê³ , sortí•¨
> ë§ˆì§€ë§‰ì— forë¬¸ì„ ëŒë ¤ ê° ìš”ì†Œë³„ ê°’ì„ ë„ì¶œ

```python
import sys
from heapq import heappop, heappush
input = sys.stdin.readline

def dijkstra():
    heap = []
    heappush(heap, (0, 1))
    dist[1][0] = 0

    while heap:
        now_w, now_node = heappop(heap)
        for nxt_w, nxt_node in link[now_node]:
            new_w = now_w + nxt_w
            if dist[nxt_node][k - 1] <= new_w:
                continue

            dist[nxt_node][k - 1] = new_w
            dist[nxt_node].sort()
            heappush(heap, (new_w, nxt_node))


n, m, k = map(int, input().split())

link = {i: [] for i in range(1, n+1)}
for _ in range(m):
    a, b, c = map(int, input().split())
    link[a].append((c, b))

dist = [[1e9] * k for _ in range(n+1)]
dijkstra()

for i in range(1, n+1):
    if dist[i][k-1] == 1e9:
        print(-1)
    else:
        print(dist[i][k-1])

```
#### ğŸ§° ë°±ì¤€ 2146 ë‹¤ë¦¬ë§Œë“¤ê¸°
> 1. `BFS`ë¥¼ í†µí•´ ê°™ì€ ì„¬ì„ ìƒ‰ì¹ í•˜ì—¬ ê°™ì€ ë¬´ë¦¬ë¡œ ì§€ì •
> 2. ê° ì„¬ì˜ ì¢Œí‘œë¥¼ ì „ë¶€ í•œ ê³³ì— ëª¨ìŒ.
> 3. ì„œë¡œ ë‹¤ë¥¸ ì„¬ë¼ë¦¬ ì¢Œí‘œê°„ì˜ ê±°ë¦¬ë¥¼ ë¹„êµí•˜ì—¬ ìµœì†Œ ì¢Œí‘œ ë„ì¶œ
```python
# ìƒí•˜ì¢Œìš° ì´ë™ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™”ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
dr = [(1,0),(0,1),(-1,0),(0,-1)]

# ê°™ì€ ì„¬ì€ ìƒ‰ì¹ í•˜ê³  ê°™ì€ ë¬´ë¦¬ë¡œ ë‹´ê¸° ìœ„í•œ BFS í•¨ìˆ˜ì…ë‹ˆë‹¤.
def BFS(x, y, num):
    # í•´ë‹¹ ì§€ì ì„ numìœ¼ë¡œ ìƒ‰ì¹ í•˜ê³ , í•´ë‹¹ ë¬´ë¦¬ì˜ ì¢Œí‘œë“¤ì„ ì„ì‹œ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.
    colors[x][y] = num
    temp = [(x, y)]
    queue = deque([[x, y]])
    while queue:
        x, y = queue.popleft()
        # ìƒí•˜ì¢Œìš°ë¡œ ì´ë™í•˜ë©° ê°™ì€ ì„¬ì„ íƒìƒ‰í•©ë‹ˆë‹¤.
        for i in range(4):
            nx = x + dr[i][0]
            ny = y + dr[i][1]
            if 0 <= nx < N and 0 <= ny < N and arr[nx][ny] and not colors[nx][ny]:
                colors[nx][ny] = num
                queue.append([nx, ny])
                temp.append((nx, ny))
    return temp

# ì…ë ¥ ë°›ê¸°
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

# ê° ì§€ì ì˜ ìƒ‰ìƒì„ ë‚˜íƒ€ë‚´ëŠ” 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
colors = [[0] * N for _ in range(N)]

# ìƒ‰ê¹”ë³„ë¡œ ë¬´ë¦¬ë¥¼ ë‚˜ëˆ„ì–´ ì €ì¥í•˜ëŠ” ë”•ì…”ë„ˆë¦¬ì…ë‹ˆë‹¤.
color_dict = {}
num = 0

# ê°™ì€ ê³³ë¼ë¦¬ ìƒ‰ì¹ ì„ ì‹œì‘í•©ë‹ˆë‹¤.
for i in range(N):
    for j in range(N):
        if arr[i][j] and not colors[i][j]:
            num += 1
            color_dict[num] = BFS(i, j, num)

# ìµœì†Œ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë³€ìˆ˜ë¥¼ ë¬´í•œëŒ€ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
min_distance = float('inf')

# ìƒ‰ê¹”ì´ ë‹¤ë¥´ë©´ ê±°ë¦¬ë¥¼ ì¬ê¸° ì‹œì‘í•©ë‹ˆë‹¤.
for combi in combinations(range(1, num+1), 2):
    a, b = combi
    for i in color_dict[a]:
        i1, i2 = i
        for j in color_dict[b]:
            j1, j2 = j
            # ë‘ ì§€ì  ê°„ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            cal_dis = abs(i1 - j1) + abs(i2 - j2) - 1
            # ìµœì†Œ ê±°ë¦¬ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
            min_distance = min(min_distance,cal_dis)
            # ìµœì†Œ ê±°ë¦¬ê°€ 1ì´ë©´ ë” ì´ìƒ ê³„ì‚°í•  í•„ìš” ì—†ì´ 1ì„ ì¶œë ¥í•˜ê³  ì¢…ë£Œí•©ë‹ˆë‹¤.
            if min_distance == 1:
                exit(print(1))

print(min_distance)
```

#### âš½ ë°±ì¤€ 7579 ì•± 
> `ë°°ë‚­`ë¬¸ì œë¥¼ í†µí•´ í’‚
> 1. ì•±ì˜ ê°¯ìˆ˜ë¥¼ í–‰ìœ¼ë¡œ, ë¹„ìš©ì˜ í•©ì„ ì—´ë¡œ í•˜ëŠ” ì´ì°¨ì› DPë¥¼ êµ¬ì„±í•œë‹¤.
> 2. ë¹„ìš©ëŒ€ë¹„ ë©”ëª¨ë¦¬ê°€ ì¢‹ì€ ê²ƒì„ êµ¬í•˜ê¸° ìœ„í•´ ì—­ìˆœìœ¼ë¡œ ìˆœíšŒ.
> 3. ëª©í‘œ ë©”ëª¨ë¦¬ë¥¼ ì²˜ìŒìœ¼ë¡œ ë‹¬ì„±í•˜ëŠ” ìµœì†Œë¹„ìš© ì°¾ìœ¼ë©´ ë¨ 
```python
N, M = map(int, input().split())
byte = list(map(int, input().split()))
cost = list(map(int, input().split()))
DP = [0] * (sum(cost)+1)  # ë¹„ìš©ë‹¹ ë¹„í™œì„±í™” ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬

for i in range(N):  # ê° ì•±ì— ëŒ€í•˜ì—¬
    for j in range(sum(cost), cost[i]-1, -1):  # ê° ë¹„ìš©ì— ëŒ€í•˜ì—¬
        # ì•±ì˜ ë¹„ìš©ì´ jë³´ë‹¤ ì‘ë‹¤ë©´
        if j >= cost[i]:
            # ë¹„í™œì„±í™”í•˜ì§€ ì•Šì•˜ì„ ë•Œì˜ ë°”ì´íŠ¸ ìˆ˜, ë¹„í™œì„±í™”í•˜ì˜€ì„ ë•Œì˜ ë°”ì´íŠ¸ ìˆ˜ë¥¼ ë”í•œ ê°’ ë¹„êµ
            DP[j] = max(DP[j], DP[j - cost[i]] + byte[i])

# í•„ìš”í•œ ë°”ì´íŠ¸ ìˆ˜ M ì´ìƒì„ ì²˜ìŒìœ¼ë¡œ ë‹¬ì„±í•˜ëŠ” ìµœì†Œ ë¹„ìš© ì°¾ê¸°
for i, mem in enumerate(DP):
    if mem >= M: exit(print(i))
```

#### ğŸ–Œ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 17681 ë¹„ë°€ì§€ë„ (2018 KAKAO BLIND RECRUITMENT)
> 1. ë‘ ìˆ˜ë¥¼ ë¹„íŠ¸ë³„ë¡œ ë¹„êµí•˜ì—¬ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ê³ , nê°œ ë¯¸ë§Œì˜ ìˆ˜ë©´ ë¹ˆìë¦¬ëŠ” 0ìœ¼ë¡œ ì±„ìš´ë‹¤.
> 2. ì—´ë§ˆë‹¤ ë‘ ìˆ˜ë¥¼ ìˆœíšŒí•˜ì—¬, `replace`ë¥¼ ì¨ì„œ,1ì€ #ìœ¼ë¡œ 0ì€ ê³µë°±ìœ¼ë¡œ ì €ì¥í•œë‹¤.

```python
def solution(n, arr1, arr2):
    return [f'{int(bin(i|j)[2:]):0{n}}'.replace("1","#").replace("0"," ") for i,j in zip(arr1,arr2)]
``` 

#### ğŸ™ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 150368 ì´ëª¨í‹°ì½˜ í• ì¸ í–‰ì‚¬(2023 KAKAO BLIND RECRUITMENT)
> 1. ê°€ëŠ¥í•œ í• ì¸ìœ¨ ì¤‘ë³µ ì¡°í•© ìƒì„±
> 2. ê° ìœ ì €ê°€ ì´ëª¨í‹°ì½˜ì„ êµ¬ë§¤í•  í• ì¸ìœ¨ê³¼ êµ¬ë§¤í•œë„ë¥¼ ì¡°íšŒí•œë‹¤.
> 3. ê·¸ ë•Œ, ê° ì´ëª¨í‹°ì½˜ì˜ í• ì¸ìœ¨ê³¼ ê°€ê²©ì„ ë¹„êµí•˜ì—¬ í• ì¸ìœ¨ ì¡°ê±´ì„ ì¶©ì¡±í•˜ë©´ ê°€ê²©ì— í•©ì‚°í•˜ê³ , í˜„ì¬ ê°€ê²©ì´ ì‚¬ìš©ìì˜ ê¸°ëŒ€ ê°€ê²© ì´ìƒì´ë©´ ì´ëª¨í‹°ì½˜ í”ŒëŸ¬ìŠ¤ ê°€ì…ììˆ˜ë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤.
> 4. ì‚¬ìš©ìê°€ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ì „ì²´ ê°€ê²©ì„ í•©ì‚°ì‹œí‚¨ë‹¤.

```python
# ì´ëª¨í‹°ì½˜ í• ì¸í–‰ì‚¬ (2023 KAKAO BLIND RECRUITMENT)
from itertools import product

def solution(users, emoticons):
    ans = []

    # ê°€ëŠ¥í•œ í• ì¸ìœ¨ ì¡°í•© ìƒì„±
    for rates in product((10, 20, 30, 40), repeat=len(emoticons)):
        cnt, price = 0, 0

        # ê° ì‚¬ìš©ìì— ëŒ€í•˜ì—¬
        for user_rate, user_price in users:
            now_cnt, now_price = 0, 0

            # ê° ì´ëª¨í‹°ì½˜ì— ëŒ€í•˜ì—¬
            for rate, emoticon in zip(rates, emoticons):

                # í˜„ì¬ í• ì¸ìœ¨ì´ ì‚¬ìš©ìì˜ ê¸°ëŒ€ í• ì¸ìœ¨ ì´ìƒì¸ ê²½ìš°
                if rate >= user_rate:
                    now_price += (emoticon // 100 * (100 - rate))

                # í˜„ì¬ ê°€ê²©ì´ ì‚¬ìš©ìì˜ ê¸°ëŒ€ ê°€ê²© ì´ìƒì´ë©´
                if now_price >= user_price:
                    now_cnt += 1; break

            # ë§Œì•½ í˜„ì¬ ì‚¬ìš©ìê°€ ë§Œì¡±í–ˆë‹¤ë©´
            if now_cnt == 1:
                cnt += 1  # ì „ì²´ ë§Œì¡±í•˜ëŠ” ì‚¬ìš©ì ìˆ˜ ì¦ê°€
            else:
                price += now_price  # ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ê°€ê²© ì¶”ê°€

        ans.append([cnt, price])

    return sorted(ans, key=lambda x: (-x[0], -x[1]))[0]
```

#### ğŸ‘” í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258707 N+1 ì¹´ë“œê²Œì„
> 1. ì¹´ë“œë¥¼ 1/3ê³¼ 2/3ë¥¼ ë‚˜ëˆ„ê³ , ì•„ë˜ ì‚¬í•­ì´ ì§„í–‰ë ë•Œë§ˆë‹¤ ë¼ìš´ë“œë¥¼ ì¶”ê°€í•œë‹¤ 
> 2. ì²«ë²ˆì§¸, ì›ë˜ ì¹´ë“œì¡°í•©ì—ì„œ ë¹„êµí•œë‹¤.
> 3. ë‘ë²ˆì§¸, ì¹´ë“œì¡°í•© + 1ê°œ ë½‘ì•˜ì„ ë•Œ ë¹„êµí•œë‹¤.(ì½”ì¸ 1ê°œ ê°ì†Œ)
> 4. ì„¸ë²ˆì§¸, ì¹´ë“œì¡°í•© + 2ê°œ ë½‘ì•˜ì„ ë•Œ ë¹„êµí•œë‹¤.(ì½”ì¸ 2ê°œ ê°ì†Œ)
> 5. ìœ„ í•´ë‹¹ì‚¬í•­ ì—†ìœ¼ë©´ í˜„ì¬ê¹Œì§€ ë¼ìš´ë“œë¥¼ ë°˜í™˜í•œë‹¤.
```python
from collections import deque
def solution(coin,cards):
    N = len(cards)
    init = cards[:N//3]
    cards = deque(cards[N//3:])
    temp = set()
    round = 1
    def pre_test(temp, init):
        for i in temp:
            for j in init:
                if i!=j and i+j == N+1:
                    temp.remove(i)
                    init.remove(j)
                    return True
        return False

    def merge(cards):
        if cards: temp.update({cards.popleft(),cards.popleft()})

    while cards:
        merge(cards)
        # 1ë‹¨ê³„ : ì‚¬ì „ì— initì—ì„œ N+1ì´ ë°œê²¬ëœë‹¤ë©´ ë‹¤ìŒ ë¼ìš´ë“œë¡œ
        if pre_test(init,init):
            round += 1
        # 2ë‹¨ê³„ : ê¸°ì¡´ initì— ì—†ê³ , ì„ íƒí•œ 1ê°œ ì¤‘ì— ìˆë‹¤ë©´ (ì½”ì¸ 1ê°œ ê°ì†Œ)
        elif coin >=1 and pre_test(init,temp):
            coin-=1
            round += 1
        # 3ë‹¨ê³„ : ê¸°ì¡´ initì— ì—†ê³ , ì„ íƒí•œ 2ê°œë¥¼ í¬í•¨í•´ ìˆë‹¤ë©´ (ì½”ì¸ 1ê°œ ê°ì†Œ)
        elif coin>=2 and pre_test(temp,temp):
            coin -=2
            round += 1
        else:
            break
    return round
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258711 ë„ë„›ê³¼ ë§‰ëŒ€ ê·¸ë˜í”„
> 1. ìƒì„± ì •ì , ë„ë„›, ë§‰ëŒ€, 8ì ê·¸ë˜í”„ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ ì§„ì…ì°¨ìˆ˜, ì§„ì¶œì°¨ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤.
> 2. ìƒì„± ì •ì  : ì§„ì…ì°¨ìˆ˜ê°€ ì—†ê³ , ì§„ì¶œì°¨ìˆ˜ê°€ ìˆëŠ” ê²½ìš°
> 3. ë§‰ëŒ€ê·¸ë˜í”„ : ì§„ì…ì°¨ìˆ˜ê°€ 1ê°œ ì´ìƒì´ê³ , ì§„ì¶œì°¨ìˆ˜ê°€ ì—†ì„ ë•Œ
> 4. 8ìê·¸ë˜í”„ : ì§„ì…ì°¨ìˆ˜ê°€ 2ê°œ ì´ìƒì´ê³ , ì§„ì¶œì°¨ìˆ˜ë„ 2ê°œ ì´ìƒì¼ ë•Œ, 
> 5. ë„ë„›ê·¸ë˜í”„ : ìƒì„±ì •ì ì˜ ì§„ì¶œì°¨ìˆ˜ - ë§‰ëŒ€ì™€ 8ìê·¸ë˜í”„ ìˆ˜
```py
def solution(edges):
    answer = [0, 0, 0, 0]  # ìƒì„± ì •ì , ë„ë„›, ë§‰ëŒ€, 8ì
    max_val = max(map(max, edges)) + 1  # +1 ì€ ì¸ë±ìŠ¤ ë§ì¶°ì£¼ê¸° ìœ„í•¨
    in_degree, out_degree = [0] * max_val, [0] * max_val

    # in, out ê°„ì„  ì €ì¥
    for now_out, now_in in edges:
        out_degree[now_out] += 1
        in_degree[now_in] += 1

    for now_node in range(1, max_val):
        # ìƒì„±ì •ì ì€ ìµœìƒìœ„ ë…¸ë“œê°™ì´ ë§¨ ì²˜ìŒì— ì‹œì‘
        if in_degree[now_node] == 0 and out_degree[now_node] >= 2:  # ìƒì„± ë…¸ë“œ
            answer[0] = now_node
        # ë§‰ëŒ€ê·¸ë˜í”„ëŠ” ë“¤ì–´ì˜¤ëŠ”ê²Œ 1ê°œ ì´ìƒì´ê³  ë‚˜ê°€ëŠ” ê²ƒì´ ì—†ì„ ë•Œ
        elif in_degree[now_node] >= 1 and out_degree[now_node] == 0:  # ë§‰ëŒ€ ê·¸ë˜í”„
            answer[2] += 1
        # ë“¤ì–´ì˜¤ëŠ” ê²ƒì´ 2ê°œ ì´ìƒì´ê³ , ë‚˜ê°€ëŠ”ê²ƒë„ 2ê°œ ì´ìƒ
        elif in_degree[now_node] >= 2 and out_degree[now_node] == 2:  # 8ì ê·¸ë˜í”„
            answer[3] += 1
    # ë„ë„›ì€ ìƒì„±ì •ì ì˜ ì•„ì›ƒ ê°œìˆ˜ - ìœ„ ë‘ê°œ ê·¸ë˜í”„ ê°¯ìˆ˜ ë¹¼ë©´ ë¨
    answer[1] = out_degree[answer[0]] - sum(answer[2:])  # ë„ë„› ê·¸ë˜í”„

    return answer
```