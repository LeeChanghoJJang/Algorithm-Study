# 1149 RGB거리

# 목표 : 모든 집을 칠하는 비용의 최솟값 구하기
# 규칙 : 서로 이웃한 집의 색은 달라야 함
# 제한 : 2 ≤ N ≤ 1000 / cost ≤ 1000 / time ≤ 500ms (O(N^2) 이내)

# < 알고리즘 선택 >
# 완전탐색 : 시간복잡도 O(2^N) -> 배제
# 그리디 : O(N) -> 통과 / 앞의 선택이 이후에 영향을 주며, 신뢰도가 낮음 -> 배제
# DPS : 완전탐색과 같은 이유 -> 배제
# DP : 문제의 최적해가 겹칠 뿐더러, 시간을 대폭 줄일 수 있으므로 고려

# < DP 배열에 들어가야할 정보 >
# 현재 색이 아닌 이전 집의 가장 싼 가격 + 현재 집에 칠할 색의 가격
# 1차원 배열도 고려 or 자체 배열에서 누계 합산 진행

N = int(input())
RGB = [list(map(int, input().split())) for _ in range(N)]

# DP 진행
for i in range(1, N):
    for j in range(3):
        RGB[i][j] += min(RGB[i-1][(j+1)%3], RGB[i-1][(j+2)%3])

print(min(RGB[-1]))

'''
시간복잡도 : O(N) / 31120KB / 40ms
'''