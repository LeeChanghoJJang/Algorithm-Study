## Algorithm Study 18íšŒì°¨ íšŒì˜ (24.6.15.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 6ì›” 15ì¼ í† ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ì†¡ì‚¼ 2ì¸µ

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 6ì›” 22ì¼ í† ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ

    ë‹¤. ë³€ê²½ì‚¬í•­
        1. ë¬¸ì œì„ ì • : ì¸ë‹¹ ê° 1ë¬¸ì œ (ì´ 7ë¬¸ì œ, ë³€ë™ì—†ìŒ)
        2. ë¬¸ì œ ë¸Œë¦¬í•‘ ë°©ì‹ ë³€ê²½ 
            - â‘  ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ íŒŒì´ì¬ìœ¼ë¡œ ë¼ì´ë¸Œ ì½”ë”©(ë‹¨, ì´ê²½ìš° ì¶”ê°€ë¡œ ìë°”ë¡œ ë¸Œë¦¬í•‘í•´ë„ ë¨)
            - â‘¡ ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ ì™¸ì—ë„ ë‹¤ë¥¸ ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œ í•˜ë‚˜ ë” ë¸Œë¦¬í•‘ ì˜ˆì •ì´ë©°, ê·¸ ì¶”ê°€ ë¬¸ì œ ì„ ì • ë°©ì‹ì€ ìê¸° "ì•"ì— ìˆëŠ” ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œë¡œ ì •í•˜ì—¬ ì¶”ê°€ë¡œ ë¸Œë¦¬í•‘ 
            - ìˆœì„œ : ë°•ë™í˜„ - ì´ê¶Œë¯¼ - ì´ì°½í˜¸ - ìœ¤ì˜ˆë¦¬ - ìµœì§€ìš°- ì´ìƒí˜„ - ì„ê²½íƒœ  (ìˆœì„œëŠ” ë§¤ë²ˆ ëœë¤ìœ¼ë¡œ ë³€ê²½ ì˜ˆì •) 
            - â‘¢ í•œë²ˆì— 2ê°œë¥¼ ë‹¤ ë¸Œë¦¬í•‘í•˜ì§€ ì•Šê³ , ì¶”ê°€ ë¬¸ì œëŠ” ë‹¤ì‹œ í•œë²ˆ ë¡œí…Œì´ì…˜ì„ ëŒ ì˜ˆì •.
    
    ë¼. ìœ ì§€ì‚¬í•­
        - ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        - ë¹„ëŒ€ë©´, ëŒ€ë©´ 1íšŒì”©. 1ì£¼ì¼ë§ˆë‹¤ í•œë²ˆ

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ìœ„ ë³€ê²½ì‚¬í•­ ì°¸ê³ 

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 2344 ê±°ìš¸(ê³¨ë“œ 4) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 11779 ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°(ê³¨ë“œ 3) 
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 2437 ì €ìš¸(ê³¨ë“œ 2)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 12689 ë®¤íƒˆë¦¬ìŠ¤í¬(ê³¨ë“œ 4)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92335 kì§„ìˆ˜ì—ì„œ ì†Œìˆ˜ ê°œìˆ˜ êµ¬í•˜ê¸°(Lv.2)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 1339 ë‹¨ì–´ ìˆ˜í•™ (ê³¨ë“œ 4)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 24533 íŒ°ë¦°ë“œë¡¬ ê²Œì„(ê³¨ë“œ 4)

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 2629 ì–‘íŒ”ì €ìš¸(ê³¨3)
   ###### 2. ì˜ˆë¦¬
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 160585 í˜¼ìì„œ í•˜ëŠ” í‹±íƒí† (Lv.2)
   ###### 3. ê²½íƒœ
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 67258 ë³´ì„ ì‡¼í•‘(Lv.3)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 3109 ë¹µì§‘ (ê³¨2)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92342 ì–‘ê¶ëŒ€íšŒ (Lv.2)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 3687 ì„±ëƒ¥ê°œë¹„ (ê³¨2)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 24533 íŒ°ë¦°ë“œë¡¬ ê²Œì„(ê³¨ë“œ 4)

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1339 ë‹¨ì–´ ìˆ˜í•™
> 1. `char` ë”•ì…”ë„ˆë¦¬ì— ê° ë‹¨ì–´ì— ë”°ë¥¸ ì‹¤ì œ ê°’ ì €ì¥(ì•„ìŠ¤í‚¤ ì½”ë“œ ì´ìš©)
> 2. char.valueê°€ ë†’ì€ ìˆœìœ¼ë¡œ 9ë¶€í„° ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ê°’ì„ ë¶€ì—¬í•˜ê¸°
```python
n = int(input())

char = {i: 0 for i in range(27)}

for _ in range(n):
    t = input()[::-1]
    for i in range(len(t)):
        char[ord(t[i])-65] += 10**i

result = 0
k = 9
for num in sorted(char.values(), key=lambda x: -x):
    if not num:
        break

    result += k * num
    k -= 1

print(result)
```
#### ğŸ§° ë°±ì¤€ 2344 ê±°ìš¸
> 1. start í•¨ìˆ˜ë¥¼ ì •ì˜í•œë‹¤. ë¹”ì˜ ìˆ«ìì™€ ë°©í–¥ì— ë”°ë¼ ì´ë™í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
> 2. ê·¸ëŸ¬ë©´ ê·¸ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë„ì°©í•˜ëŠ” ë¶€ë¶„ì˜ ìœ„ì¹˜ë¥¼ ë°˜í™˜í•œë‹¤.

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
box = [list(map(int, input().split())) for _ in range(N)]


def start(v, d):
    if d == 0:p = [(v, 0)]
    elif d == 1:p = [(N-1, v)]
    elif d == 2:p = [(v, M-1)]
    else:p = [(0, v)]

    while p:
        x, y = p.pop()

        if box[x][y]:
            d = change_dr[d]
        dx, dy = dr[d]
        nx, ny = x + dx, y + dy
        if 0 <= nx < N and 0 <= ny < M:
            p.append((nx, ny))
        else:
            if nx == -1:return 2*N + 2*M - ny
            elif ny == -1:return nx+1
            elif nx == N:return N + ny + 1
            else:return 2*N + M - nx


dr = [(0, 1), (-1, 0), (0, -1), (1, 0)]
change_dr = [1, 0, 3, 2]
result = []
for i in range(N):
    result.append(start(i, 0))

for i in range(M):
    result.append(start(i, 1))

for i in range(N):
    result.append(start(N-i-1, 2))

for i in range(M):
    result.append(start(M-i-1, 3))

print(*result)
```

#### âš½ ë°±ì¤€ 2437 ê³¼ì œ
> ì–´ë–¤ ìˆ«ìë³´ë‹¤ ì‘ì€ ëª¨ë“  ìˆ«ìë“¤ì˜ í•©ì´ ê·¸ ìˆ«ìê°€ ë˜ì§€ ì•Šìœ¼ë©´ ì—°ì†ì ì´ì§€ ì•ŠëŠ” ì„±ì§ˆì„ ì´ìš©í•œë‹¤.

```python
# 2437 ì €ìš¸
_ = int(input())
weights = sorted(map(int, input().split()))

# í˜„ì¬ê¹Œì§€ ì¸¡ì • ê°€ëŠ¥í•œ ìµœëŒ€ ë¬´ê²Œ
sum_v = 0

for w in weights:
    # ì‚¬ì´ ê°„ê²©ì´ 1ì´ ì•„ë‹ˆë¼ë©´ ì¢…ë£Œ
    if w > sum_v + 1:
        break
    sum_v += w

# ì¸¡ì •í•  ìˆ˜ ì—†ëŠ” ê°€ì¥ ì‘ì€ ë¬´ê²Œ ì¶œë ¥
print(sum_v + 1)
```

#### ğŸ–Œ ë°±ì¤€ 11779 ìµœì†Œë¹„ìš© êµ¬í•˜ê¸° 2
> 1. ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í†µí•´ start ì§€ì ë¶€í„° end ì§€ì ê¹Œì§€ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•œë‹¤.
> 2. íŠ¸ë¦¬ì˜ êµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ ê²½ë¡œë¥¼ ì´ë™í•˜ë©´ì„œ start ì§€ì ì„ end ì¸ë±ìŠ¤ì— ì €ì¥í•œë‹¤.
> 3. whileë¬¸ì„ í†µí•´ íŠ¸ë¦¬ì— endì¸ë±ìŠ¤ì— í•´ë‹¹ë˜ëŠ” startë¥¼ ê³„ì† ë°˜í™˜í•œë‹¤. (startì™€ endê°€ ë™ì¼í•˜ê¸° ì „ê¹Œì§€)

```python
import sys
sys.stdin = open('input.txt')
from collections import defaultdict
from heapq import heappush,heappop
input=sys.stdin.readline
def dijkstra(start):
    dist[start] = 0
    heap = []
    heappush(heap,(0,start))
    while heap:
        wei,now = heappop(heap)
        if dist[now] < wei:
            continue
        for next_node, next_wei in graph[now]:
            next_cost = wei + next_wei
            if next_cost < dist[next_node]:
                dist[next_node] = next_cost
                prev_node[next_node] = now
                heappush(heap,(next_cost,next_node))

N = int(input())
M = int(input())
graph = defaultdict(list)
dist = [float('inf')] * (N + 1)
prev_node = [0] * (N+1)
for i in range(M):
    start,end,wei = map(int,input().split())
    graph[start].append((end,wei))

start, end = map(int,input().split())
dijkstra(start)
print(dist[end])
path = [end]
now = end
while now != start:
    now = prev_node[now]
    path.append(now)

path.reverse()

print(len(path))
print(' '.join(map(str, path)))
``` 

#### ğŸ™ ë°±ì¤€ 12869 ë®¤íƒˆë¦¬ìŠ¤í¬
> 1. ì ì˜ ì²´ë ¥ì„ ê¹ëŠ” ìµœì†Œí•œì˜ íšŸìˆ˜ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ DPë¥¼ ì“´ë‹¤. 
> 2. DPëŠ” ê° SCVì˜ ì›ì†Œë¥¼ í•˜ë‚˜ì”© ëŒ€ì‘ì‹œì¼œ ìµœì†Œ ê³µê²© íšŸìˆ˜ë¥¼ ê° DPì— ì €ì¥í•œë‹¤.

```python
from collections import deque

N = int(input())
SCV = list(map(int, input().split()))
SCV += [0] * (3 - len(SCV))

# ê³µê²© ì¡°í•© ì„¤ì •
attacks = [(9, 3, 1), (9, 1, 3), (3, 9, 1), (3, 1, 9), (1, 9, 3), (1, 3, 9)]

# DP í…Œì´ë¸” ì´ˆê¸°í™”
DP = [[[float('inf')] * 61 for _ in range(61)] for __ in range(61)]

# BFS ì´ˆê¸° ì„¤ì •
Q = deque([SCV])
DP[SCV[0]][SCV[1]][SCV[2]] = 0

while Q:
    a, b, c = Q.popleft()

    # ê°€ëŠ¥í•œ ëª¨ë“  ê³µê²© ì¡°í•©ì— ëŒ€í•´ ìƒˆë¡œìš´ ìƒíƒœë¥¼ ê³„ì‚°
    for attack in attacks:
        nx, ny, nz = max(0, a - attack[0]), max(0, b - attack[1]), max(0, c - attack[2])

        # ìƒˆë¡œìš´ ìƒíƒœì—ì„œì˜ ìµœì†Œ ê³µê²© íšŸìˆ˜ë¥¼ ê°±ì‹ í•  ìˆ˜ ìˆëŠ” ê²½ìš°
        if DP[nx][ny][nz] > DP[a][b][c] + 1:
            DP[nx][ny][nz] = DP[a][b][c] + 1  # ìµœì†Œ ê³µê²© íšŸìˆ˜ ê°±ì‹ 
            Q.append((nx, ny, nz))  # ìƒˆë¡œìš´ ìƒíƒœë¥¼ íì— ì¶”ê°€

# ëª¨ë“  ì ì˜ ì²´ë ¥ì„ 0ìœ¼ë¡œ ë§Œë“œëŠ” ìµœì†Œ ê³µê²© íšŸìˆ˜ ì¶œë ¥
print(DP[0][0][0])

```

#### ğŸ‘” ë°±ì¤€ 24553 íŒ°ë¦°ë“œë¡¬ ê²Œì„
> 1. ì²˜ìŒ ì‹œì‘í•˜ëŠ” ê²½ìš°ì—ëŠ” í•œìë¦¿ìˆ˜ë©´ ë¬´ì¡°ê±´ ìŠ¹ë¦¬í•œë‹¤.
> 2. 10ì˜ ë°°ìˆ˜ì¸ ê²½ìš° ì „ë¶€ ë‹¤ê°€ì ¸ê°€ì§€ ëª»í•˜ê¸° ë•Œë¬¸ì—, í›„ë°œì£¼ìê°€ ìŠ¹ë¦¬í•œë‹¤.
> 3. ë”°ë¼ì„œ 10ì˜ ë°°ìˆ˜ê°€ ì•„ë‹ë•Œë§Œ ìŠ¹ë¦¬í•˜ëŠ” í‰ê°€ì‹ì„ ì ìœ¼ë©´ ëœë‹¤.
```python
# 24553 íŒ°ë¦°ë“œë¡¬ ê²Œì„
for _ in range(int(input())):
    # Nì´ 10ì˜ ë°°ìˆ˜ì¸ ê²½ìš° ì„ ê³µì´ ë¬´ì¡°ê±´ ìŠ¹ë¦¬
    print(0 if int(input()) % 10 else 1)
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92335 kì§„ìˆ˜ì—ì„œ ì†Œìˆ˜ ê°œìˆ˜ êµ¬í•˜ê¸°
> 1. ë¨¼ì €, ì£¼ì–´ì§„ ë¬¸ìì—´ì„ 0ì„ ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•œë‹¤.
> 2. ê° ë¬¸ìë¥¼ ìˆ«ìë¡œ ë³€í™˜í•œ í›„, ì†Œìˆ˜ì¸ì§€ íŒì •í•˜ê³  ì¹´ìš´íŠ¸ë¥¼ í•œë‹¤.

```py
# nì„ kì§„ë²•ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ ë°˜í™˜
def conv(n, k):
    s = ''
    while n:
        s += str(n%k)
        n //= k
    return s[::-1]

# nì´ ì†Œìˆ˜ì¸ì§€ íŒì •
def isprime(n):
    if n <= 1: return False
    i = 2
    while i*i <= n:
        if n%i == 0: return False
        i += 1
    return True

def solution(n, k):
    s = conv(n,k)
    cnt = 0
    for num in s.split('0'):
        if not num: continue # ë¹ˆ ë¬¸ìì—´ì— ëŒ€í•œ ì˜ˆì™¸ì²˜ë¦¬
        if isprime(int(num)): cnt += 1
    return cnt
```