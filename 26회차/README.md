## Algorithm Study 26íšŒì°¨ íšŒì˜ (24.8.24.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 8ì›” 24ì¼ í† ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ 

    ë‚˜. ë³€ê²½ì‚¬í•­
        1. ë¬¸ì œì„ ì • : ì¸ë‹¹ ê° 1ë¬¸ì œ (ì´ 7ë¬¸ì œ, ë³€ë™ì—†ìŒ)
        2. ë¬¸ì œ ë¸Œë¦¬í•‘ ë°©ì‹ ë³€ê²½ 
            - â‘  ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ íŒŒì´ì¬ìœ¼ë¡œ ë¼ì´ë¸Œ ì½”ë”©(ë‹¨, ì´ê²½ìš° ì¶”ê°€ë¡œ ìë°”ë¡œ ë¸Œë¦¬í•‘í•´ë„ ë¨)
            - â‘¡ ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ ì™¸ì—ë„ ë‹¤ë¥¸ ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œ í•˜ë‚˜ ë” ë¸Œë¦¬í•‘ ì˜ˆì •ì´ë©°, ê·¸ ì¶”ê°€ ë¬¸ì œ ì„ ì • ë°©ì‹ì€ ìê¸° "ì•"ì— ìˆëŠ” ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œë¡œ ì •í•˜ì—¬ ì¶”ê°€ë¡œ ë¸Œë¦¬í•‘ 
            - ìˆœì„œ : ì´ìƒí˜„ - ì„ê²½íƒœ - ì´ê¶Œë¯¼ - ì´ì°½í˜¸ - ë°•ë™í˜„ - ìµœì§€ìš° - ìœ¤ì˜ˆë¦¬  (ìˆœì„œëŠ” ë§¤ë²ˆ ëœë¤ìœ¼ë¡œ ë³€ê²½ ì˜ˆì •) 
            - â‘¢ í•œë²ˆì— 2ê°œë¥¼ ë‹¤ ë¸Œë¦¬í•‘í•˜ì§€ ì•Šê³ , ì¶”ê°€ ë¬¸ì œëŠ” ë‹¤ì‹œ í•œë²ˆ ë¡œí…Œì´ì…˜ì„ ëŒ ì˜ˆì •.
    
    ë‹¤. ìœ ì§€ì‚¬í•­
        - ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        - ë¹„ëŒ€ë©´, ëŒ€ë©´ 1íšŒì”©. 1ì£¼ì¼ë§ˆë‹¤ í•œë²ˆ

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ìœ„ ë³€ê²½ì‚¬í•­ ì°¸ê³ 

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 14267 íšŒì‚¬ ë¬¸í™” 1 (ê³¨4)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 3425 ê³ ìŠ¤íƒ (ê³¨4)
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 1707 ì´ë¶„ ê·¸ë˜í”„ (ê³¨4)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 17835 ë©´ì ‘ë³´ëŠ” ìŠ¹ë²”ì´ë„¤ (ê³¨2)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 1099 ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì¥ (ê³¨3)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 1135 ë‰´ìŠ¤ ì „í•˜ê¸° (ê³¨2)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 9370 ë¯¸í™•ì¸ ë„ì°©ì§€ (ê³¨2)
    
### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1099 ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì¥
> 1. ë¬¸ì¥ì—ì„œ ê° ë‹¨ì–´ë³„ë¡œ ì¶”ì¶œí•˜ì—¬ í•´ì„ë  ìˆ˜ ìˆëŠ” ë‹¨ì–´ë¼ë©´ ë¹„ìš©ì´ ë‹¤ë¥¸ë§Œí¼ dpì— ì €ì¥í•œë‹¤.
> 2. ë¬¸ì¥ì˜ ië²ˆì§¸ ë¬¸ìì—ì„œ jë²ˆì§¸ ë¬¸ìê¹Œì§€ í•´ì„í•˜ëŠ”ë° ìµœì†Œë¹„ìš©ì„ ëˆ„ì ì‹œì¼œê°„ë‹¤.

```python
# 1099 ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì¥

sentence = " " + input()
n = int(input())
words = [input() for _ in range(n)]

# dp[i][j]: ë¬¸ì¥ì˜ ië²ˆì§¸ ë¬¸ìë¶€í„° jë²ˆì§¸ ë¬¸ìê¹Œì§€ì˜ êµ¬ê°„ì„ í•´ì„í•˜ëŠ” ë° í•„ìš”í•œ ìµœì†Œ ë¹„ìš©
dp = [[1000] * (len(sentence)) for _ in range(len(sentence))]
dp[0][0] = 0

# ë‹¨ì–´ í•´ì„ ë¹„ìš© í•¨ìˆ˜
def check(word1, word2, length):
    cnt = 0
    for i in range(length):
        if word1[i] != word2[i]:
            cnt += 1
    return cnt

for i in range(1, len(sentence)+1):
    # ì•ì„œ ì—°ê²°ë  ìˆ˜ ìˆëŠ” ë‹¨ì–´ê°€ ì—†ìŒ
    if dp[i-1][0] == 1000:
        continue

    for word in words:
        length = len(word)

        # í•´ì„ë  ìˆ˜ ìˆëŠ” ë‹¨ì–´
        if sorted(sentence[i:i+length]) == sorted(word):
            dp[i][i+length-1] = min(dp[i][i+length-1], dp[i-1][0] + check(sentence[i:i+length], word, length))
            # ë§¨ ì•ì— í˜„ì¬ ê¸¸ì´ê¹Œì§€ì˜ ìµœì†Ÿê°’ ì—…ë°ì´íŠ¸
            dp[i+length-1][0] = min(dp[i+length-1][0], dp[i][i+length-1])

print(dp[-1][0] if dp[-1][0] != 1000 else -1)

```
#### ğŸ§° ë°±ì¤€ 1135 ë‰´ìŠ¤ ì „í•˜ê¸°
> 1. ë¶€ëª¨ ë¦¬ìŠ¤íŠ¸ë“¤ì„ ìì‹ë¦¬ìŠ¤íŠ¸ë¡œ ì „í™˜í•œë‹¤.
> 2. dfsë¥¼ í†µí•´ ìì‹ë…¸ë“œì˜ ìµœì†Œ ì‹œê°„ì„ êµ¬í•œë‹¤.  

```python
import sys
input = sys.stdin.readline
N = int(input())
parent_list = list(map(int, input().split()))
child_list = [list() for _ in range(N)]

for child in range(1, N) :
  parent = parent_list[child]
  child_list[parent].append(child)

def dfs(node) :
  if not child_list[node] :
    return 0
  result = list()
  for child in child_list[node] :
    result.append(dfs(child))
  result.sort( reverse = True)
  result = [ result[i] + i + 1 for i in range(len(child_list[node])) ]
  return max(result)

print(dfs(0))


```

#### âš½ ë°±ì¤€ 1707 ì´ë¶„ ê·¸ë˜í”„
> 1. ë¬´ë°©í–¥ ê·¸ë˜í”„ë¥¼ ê·¸ë ¤ì„œ, BFSë¡œ ì´ë™í•˜ë©´ ì¸ì ‘ ë…¸ë“œì™€ ë‹¤ë¥¸ ê·¸ë£¹ìœ¼ë¡œ ì„¤ì •í•œë‹¤.
> 2. ë§Œì•½, ë°©ë¬¸í–ˆì„ ë•Œ, ê°™ì€ ê·¸ë£¹ì´ë©´ ì´ë¶„ ê·¸ë˜í”„ê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤.

```python
import sys
from collections import deque
input = sys.stdin.readline

# bfs
def bfs(start, group):
    queue = deque([start])  # ì‹œì‘ ì •ì  ê°’ì„ íì— ë‹´ëŠ”ë‹¤.
    visited[start] = group  # ì‹œì‘ ì •ì  ê·¸ë£¹ì„ ì„¤ì •
    while queue:  # íê°€ ì¡´ì¬í• ë•Œê¹Œì§€ ëˆë‹¤.
        x = queue.popleft()  # íì˜ ë§¨ì• ì›ì†Œë¥¼ ë¹¼ë‚¸ë‹¤.
        for i in graph[x]:  # í•´ë‹¹ ì •ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” í•˜ìœ„ ì •ì ë“¤ì„ ëˆë‹¤.
            if not visited[i]:  # ë§Œì•½ ê·¸ ì •ì ë“¤ì„ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
                queue.append(i)  # ê·¸ ì •ì ë“¤ì„ ì¶”ê°€í•˜ê³ 
                visited[i] = -1 * visited[x]  # ìƒìœ„ ì •ì ê³¼ ë‹¤ë¥¸ ê·¸ë£¹ìœ¼ë¡œ í¸ì„±
            elif visited[i] == visited[x]:  # ë§Œì•½ ì •ì ë“¤ì„ ì´ë¯¸ ë°©ë¬¸í–ˆì—ˆëŠ”ë° ê°™ì€ ê·¸ë£¹ì´ë¼ë©´
                return False  # Falseë¥¼ ë°”ë¡œ ë¦¬í„´
    return True  # ìœ„ì˜ ì¡°ê±´ì— ê±¸ë¦¬ì§€ ì•Šì•˜ë‹¤ë©´ Trueë¥¼ ë¦¬í„´

for _ in range(int(input())):
    V, E = map(int, input().split())
    graph = [[] for i in range(V + 1)]  # ë¹ˆ ê·¸ë˜í”„ ìƒì„±
    visited = [False] * (V + 1)  # ë°©ë¬¸í•œ ì •ì  ì²´í¬

    for _ in range(E):
        a, b = map(int, input().split())
        graph[a].append(b)  # ë¬´ë°©í–¥ ê·¸ë˜í”„
        graph[b].append(a)  # ë¬´ë°©í–¥ ê·¸ë˜í”„

    for i in range(1, V + 1):
        if not visited[i]:  # ë°©ë¬¸í•œ ì •ì ì´ ì•„ë‹ˆë©´, bfs ìˆ˜í–‰
            result = bfs(i, 1)
            if not result:
                break

    print('YES' if result else 'NO')
```

#### ğŸ–Œ ë°±ì¤€ 3425 ê³ ìŠ¤íƒ
> 1. operatorë¥¼ ì„¤ì •í•˜ê³ , whileë¬¸ì„ ë°˜ë³µí•˜ì—¬ ê° inputì„ ë°›ëŠ”ë‹¤.
> 2. í•´ë‹¹ ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•œë‹¤.

```python
import sys
sys.stdin =open('input.txt')
input = sys.stdin.readline

while True:
    operator = []
    while True:
        operator.append(input().strip())
        if operator[-1] == 'QUIT': quit()
        if operator[-1] == 'END': break

    for _ in range(int(input())):
        try:
            stack = [int(input())]
            for o in operator:
                if o == 'END': break
                if o[:3] == 'NUM':
                    stack.append(int(o[4:]))
                elif o == 'POP':
                    stack.pop()
                elif o == 'INV':
                    stack[-1] *= -1
                elif o == 'DUP':
                    stack.append(stack[-1])
                else:
                    a = stack.pop()
                    b = stack.pop()
                    if o == 'SWP':
                        stack.append(a)
                        stack.append(b)
                    elif o == 'ADD':
                        stack.append(a + b)
                    elif o == 'SUB':
                        stack.append(b - a)
                    elif o == 'MUL':
                        stack.append(a * b)
                    elif o == 'DIV':
                        if b / a < 0:
                            stack.append((abs(b) // abs(a)) * -1)
                        else:
                            stack.append(abs(b) // abs(a))
                    elif o == 'MOD':
                        if b < 0:
                            stack.append((abs(b) % abs(a)) * -1)
                        else:
                            stack.append(abs(b) % abs(a))
                if stack and abs(stack[-1]) > 10 ** 9: raise
            if len(stack) != 1: raise
        except:
            stack = ['ERROR']
        print(stack[0])

    print()
    input()

``` 

#### ğŸ™ ë°±ì¤€ 9370 ë¯¸í™•ì¸ ë„ì°©ì§€ 
> 1. ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ í†µí•´, s -> g- > h -> eë¡œ í–¥í•˜ëŠ” ê±°ë¦¬ì™€ s -> eë¡œ ê°€ëŠ” ê±°ë¦¬ê°€ ê°™ì€ ê²½ìš°ë¥¼ ì¶”ë¦°ë‹¤.
> 2. ìœ„ ë„ì°©ì§€ë“¤ì„ í•˜ë‚˜ì”© ì¶œë ¥í•œë‹¤.
```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

def dijkstra(start):
    distance = [INF] * (n+1)
    q = []
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:
        dist, now = heapq.heappop(q)
        if distance[now] < dist:
            continue
        for i in graph[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))
    return distance


T = int(input())
for _ in range(T):
    n, m, t = map(int, input().split())
    s, g, h = map(int, input().split())

    graph = [[] for _ in range(n+1)]
    end = []

    for _ in range(m):
        a, b, d = map(int, input().split())
        graph[a].append((b, d))
        graph[b].append((a, d))

    for i in range(t):
        end.append(int(input()))

    Ds = dijkstra(s)
    Dg = dijkstra(g)
    Dh = dijkstra(h)

    result = []
    for e in end:
        if Ds[g] + Dg[h] + Dh[e] == Ds[e] or Ds[h] + Dh[g] + Dg[e] == Ds[e]:
            result.append(e)

    result.sort()
    for r in result:
        print(r, end=' ')
```

#### ğŸ‘” ë°±ì¤€ 14267 íšŒì‚¬ ë¬¸í™” 1 
> 1. ì¹­ì°¬ ì ìˆ˜ë¥¼ point ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•œë‹¤.
> 2. í•´ë‹¹ ì§ì†ìƒê´€ì˜ ì¹­ì°¬ì ìˆ˜ë¥¼ ëˆ„ì í•´ì„œ point ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•œë‹¤.
> 3. í•˜ë‚˜ì”© ì¶œë ¥í•œë‹¤.

```py
import sys
sys.stdin = open('input.txt')
input = sys.stdin.readline

n, m = map(int, input().split())
parent = [0] + list(map(int, input().split()))
point = [0] * (n + 1)

for i in range(m):  # ì…ë ¥ë°›ì€ ì¹­ì°¬ì ìˆ˜ë¥¼ ë”í•´ì£¼ëŠ” ë¶€ë¶„
    u, cnt = map(int, input().split())
    point[u] += cnt

for i in range(2, n + 1):  # ì§ì†ìƒê´€ì˜ ì¹­ì°¬ì ìˆ˜ë¥¼ ë”í•´ì£¼ëŠ” ë¶€ë¶„
    point[i] += point[parent[i]]

for i in range(1, len(point)):
    print(point[i], end=' ')
```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 17835 ë©´ì ‘ë³´ëŠ” ìŠ¹ë²”ì´ë„¤
> 1. ê±°ë¦¬ê°€ ê°€ì¥ ë¨¼ ë„ì‹œì˜ ë²ˆí˜¸ë¥¼ ì—­ì¶”ì í•˜ê¸° ìœ„í•´ ë„ì°©ì§€ -> ì¶œë°œì§€ì˜ ì—­ë°©í–¥ ê·¸ë˜í”„ë¥¼ ê·¸ë¦°ë‹¤.
> 2. ë©´ì ‘ì¥ ë‹¤ìŒ ë„ì‹œë¶€í„° í™ì— ê±°ë¦¬ì™€ ìœ„ì¹˜ë¥¼ ì €ì¥í•œë‹¤.
> 3. ê·¸ë¦¬ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ì´ ë‚˜ì˜¬ë•Œê¹Œì§€ ë°˜ë³µë¬¸ì„ ëŒë¦¬ë©´ì„œ, ìµœì†Œ ê±°ë¦¬ê°€ ë‚˜ì˜¬ë•Œ ê±°ë¦¬ë¥¼ ì¶œë ¥í•œë‹¤.

```py
import sys
sys.stdin = open('input.txt')
from heapq import *
input =sys.stdin.readline

n,m,k = map(int,input().split())
graph = [[] for i in range(n+1)]

# ì—­ë°©í–¥ ê·¸ë˜í”„
for _ in range(m):
    a,b,w = map(int,input().split())
    graph[b].append((a,w))

# ë©´ì ‘ì¥
data = [*map(int,input().split())]
check = [0]*(n+1); hq = []

# í”„ë¦¼ì˜ ì›ë¦¬ë¥¼ ì´ìš©
# ë©´ì ‘ì¥ ë‹¤ìŒ ë„ì‹œë¶€í„° í™ì— ì €ì¥
for a in data:
    check[a] = 1
    for b,w in graph[a]:
        heappush(hq,(w,-b))

# ë³€ìˆ˜ì˜ ì´ˆê¸°ê°’ ì„¤ì •
now,w = -1,0
for _ in range(n-k):
    while 1:
        w,now = heappop(hq)
        if check[-now]:
            continue
        break
    check[-now] = 1
    for next,w1 in graph[-now]:
        heappush(hq,(w+w1,-next))
print(-now);print(w)
```
