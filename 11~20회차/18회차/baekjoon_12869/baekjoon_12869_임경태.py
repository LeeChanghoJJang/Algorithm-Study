# 12869 뮤탈리스크
from collections import deque

N = int(input())
SCV = list(map(int, input().split()))
SCV += [0] * (3 - len(SCV))

# 공격 조합 설정
attacks = [(9, 3, 1), (9, 1, 3), (3, 9, 1), (3, 1, 9), (1, 9, 3), (1, 3, 9)]

# DP 테이블 초기화
DP = [[[float('inf')] * 61 for _ in range(61)] for __ in range(61)]

# BFS 초기 설정
Q = deque([SCV])
DP[SCV[0]][SCV[1]][SCV[2]] = 0

while Q:
    a, b, c = Q.popleft()

    # 가능한 모든 공격 조합에 대해 새로운 상태를 계산
    for attack in attacks:
        nx, ny, nz = max(0, a - attack[0]), max(0, b - attack[1]), max(0, c - attack[2])

        # 새로운 상태에서의 최소 공격 횟수를 갱신할 수 있는 경우
        if DP[nx][ny][nz] > DP[a][b][c] + 1:
            DP[nx][ny][nz] = DP[a][b][c] + 1  # 최소 공격 횟수 갱신
            Q.append((nx, ny, nz))  # 새로운 상태를 큐에 추가

# 모든 적의 체력을 0으로 만드는 최소 공격 횟수 출력
print(DP[0][0][0])

'''
1. 문제의 특성 파악
목표 : 적의 체력 3개를 최소한의 공격 횟수로 0으로 만드는 것
여러 단계의 상태 변화(적의 체력 감소)가 있으며, 각 단계에서 최적의 결정을 내려야 함

2. 상태 변화와 최적 부분 구조
각 공격에서 적의 체력은 감소하며, 이러한 감소는 다양한 조합으로 이루어짐
현재 상태(적의 체력 상태)에서의 최적의 해법이 다음 상태에서도 최적의 해법이 되는 특성,
즉 최적 부분 구조(optimal substructure)를 가진다.

3. 중복 계산 방지
동일한 체력 상태에서 동일한 공격 조합을 반복해서 계산하는 것을 피해야 함
상태 공간을 저장하여 이미 계산된 상태는 재계산하지 않도록 해야 함

4. DP 접근법 떠올리기
이러한 상태 변화와 중복 계산 방지를 고려하면, DP 접근법을 연상
상태 공간을 테이블(여기서는 3차원 배열)로 관리하고, 각 상태에서의 최적 값을 저장하는 방식이 적합하다.

5. 문제의 요구사항과 일치하는 방법 선택
최소한의 공격 횟수를 구하는 것이므로 BFS와 DP를 결합한 형태가 적합
BFS를 통해 각 상태를 레벨 단위로 탐색하면서, DP 테이블 사용하여 최적 값 관리
'''