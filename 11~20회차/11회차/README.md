## Algorithm Study 11íšŒì°¨ íšŒì˜ (24.4.13.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 4ì›” 13ì¼ í† ìš”ì¼ ì•„ì¹¨ 9ì‹œ 30ë¶„  
        - ë°©ì‹ : ê¹€í•´ ì»¤í”¼íŒ€ë²„ 

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 4ì›” 21ì¼ ì¼ìš”ì¼ ì•„ì¹¨ 9ì‹œ  
        - ë°©ì‹ : ë¹„ëŒ€ë©´ ë””ìŠ¤ì½”ë“œ 

    ë‹¤. ì•ˆê±´ ì‹¬ì˜(íˆ¬í‘œ) ê²°ê³¼
        1. ìŠ¤í„°ë””ì› ëª¨ì§‘ 2ëª…(ìµœì§€ìš°, ì´ê¶Œë¯¼) : ê°€ê²°(ì „ì› í•©ì˜)
        2. ì½”ë“œë¦¬ë·° ë°©ì‹ ë³€ê²½ : ê°€ê²°(ì „ì› í•©ì˜)
        3. 8ì¡° íŒ¨ë„í‹° ê´€ë ¨ ê·œì • ê°œì„  : ë¶€ê²°(ê³¼ë°˜ìˆ˜ ë°˜ëŒ€)
    
    ë¼. ë³€ê²½ì‚¬í•­ ìš”ì•½ (4ì›” 21ì¼ ì´í›„)
        1. ê°ì ì„ ì •í•œ 1ë¬¸ì œ ë¦¬ë·°(ëª¨ë‘ ì•ì—ì„œ ë°”ë¡œ í’€ ìˆ˜ ìˆì„ ë§Œí¼) 
            - ìš”ì²­ìˆê±°ë‚˜, ë§í•˜ê³  ì‹¶ì€ ì‚¬ëŒì€ ìê¸° ë¬¸ì œ ì•„ë‹ˆë¼ë„ ì¶”ê°€ ë¦¬ë·° ê°€ëŠ¥
        2. ê°ì 1ë¬¸ì œì”©ë§Œ ì„ ì •(ì´ 7ë¬¸ì œ)
        3. ì¼ì • ê¸°ë³¸ê°’: ë§¤ì£¼ í† ìš”ì¼ 9ì‹œ ë°˜ â†’ ë§¤ì£¼ ì¼ìš”ì¼ ì €ë… 7ì‹œ
            - ì¼ì • ë³€ê²½ ì‹œ, ì‚¬ì „í˜‘ì˜í•˜ì—¬ ë³€ê²½. ë³€ê²½ë¶ˆê°€ ì‹œ ë¶ˆì°¸ë¹„ ì§€ì¶œ è¦.

    ë§ˆ. 4ì›” ì¼ì •
        1. 4ì›” 21ì¼ ì¼ìš”ì¼ ì˜¤ì „ 9ì‹œ ë¹„ëŒ€ë©´ ë””ìŠ¤ì½”ë“œ
        2. 4ì›” 28ì¼ ì¼ìš”ì¼ ì €ë… 7ì‹œ ê¹€í•´ ì»¤í”¼íŒ€ë²„
            - ë‹¨, ì¥ì†ŒëŠ” í˜‘ì˜í•˜ì—¬ ë³€ê²½ë  ìˆ˜ ìˆìŒ

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• :ã€ìœ í˜•ã€ ë³„ë¡œ 'ê°ì' 'ìƒ', 'í•˜' ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 2ë¬¸ì œ, ì´ 10ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ : ìµœëŒ€ ë°±ì¤€ ê³¨ë“œ ì´í•˜ 
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ì´ë²ˆ ì£¼ì˜ ìƒˆë¡œìš´ ë¬¸ì œ : ìœ„ìƒì •ë ¬
      - ë¬¸ì œ ì„ ì •ìê°€ í‘¼ ë°©ì‹ ë¸Œë¦¬í•‘
      - í‘¼ ë°©ì‹ ì´ì™¸ì—ë„ ë‹¤ì–‘í•œ ë°©ë²• ì œì‹œ
      - ë¬¸ì œ ì ‘ê·¼ ë°©ì‹ ìš°ì„ ìˆœìœ„ ë“± ì´ì²´ì  ì •ë¦¬

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 14567 ì„ ìˆ˜ê³¼ëª©(ê³¨ë“œ 5)
    - ë°±ì¤€ 15565 ê·€ì—¬ìš´ ë¼ì´ì–¸(ì‹¤ë²„ 1)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 1450 ëƒ…ìƒ‰ë¬¸ì œ(ê³¨ë“œ 1)
    - ë°±ì¤€ 7576 í† ë§ˆí† (ê³¨ë“œ 5)
   ###### 3. ê²½íƒœ
    - swea 2477 ì°¨ëŸ‰ ì •ë¹„ì†Œ(Aí˜• ëŒ€ë¹„)
    - ë°±ì¤€ 9465 ìŠ¤í‹°ì»¤(ì‹¤ë²„ 1)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 16562 ì¹œêµ¬ë¹„(ê³¨ë“œ 4)
    - ë°±ì¤€ 13335 íŠ¸ëŸ­(ì‹¤ë²„ 1)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 1326 ì†ŒíŠ¸ê²Œì„(ê³¨ë“œ 4)
    - ë°±ì¤€ 20529 ê°€ì¥ ê°€ê¹Œìš´ ì„¸ ì‚¬ëŒì˜ ì‹¬ë¦¬ì  ê±°ë¦¬(ì‹¤ë²„ 1)

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 1197 ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(ê³¨ë“œ 4)
    - ë°±ì¤€ 1991 íŠ¸ë¦¬ ìˆœíšŒ(ì‹¤ë²„ 1)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 2252 ì¤„ ì„¸ìš°ê¸° (ê³¨ë“œ3)
    - ë°±ì¤€ 11729 í•˜ë…¸ì´íƒ‘ ì´ë™ ìˆœì„œ (ê³¨ë“œ5)
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 1799 ë¹„ìˆ (ê³¨ë“œ1)
    - ë°±ì¤€ 17626 Four Squares (ì‹¤ë²„3)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 1987 ì•ŒíŒŒë²³ (ê³¨ë“œ4)
    - ë°±ì¤€ 15903 ì¹´ë“œ í•©ì²´ ë†€ì´ (ì‹¤ë²„1)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 14427 ìˆ˜ì—´ê³¼ ì¿¼ë¦¬ 15(ê³¨ë“œ 3) - ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬
    - ë°±ì¤€ 5567 ê²°í˜¼ì‹(ì‹¤ë²„ 2)  

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1327 ì†ŒíŠ¸ê²Œì„
> `BFS` ì´ìš©í•œ ë¬¸ì œ í’€ì´ 
> 1. N : ìˆœì—´ì˜ í¬ê¸° / K : ìˆœì—´ì— ë“¤ì–´ê°€ëŠ” ìˆ˜ ì£¼ì–´ì§
> 2. ì •ë ¬ëœ ìˆœì—´(ëª©í‘œìˆœì—´)ì„ ì •ì˜í•˜ê³ , `BFS`ë¥¼ ì´ìš©
> 3. ëª©í‘œì™€ ê°™ì€ ê²½ìš°ì—ë§Œ ë³¸ ë°˜ë³µë¬¸ íƒˆì¶œ
> 4. ë°©ë¬¸í•œ ì  ìˆëŠ” ë°°ì—´ì€ visitedì— ì €ì¥í•˜ì—¬ í–¥í›„ ë°©ë¬¸ ì œì™¸
> 5. ë” ì´ìƒ íƒìƒ‰í•  ê²ƒì´ ì—†ì´ ë°˜ë³µë¬¸ íƒˆì¶œ ì‹œ, -1 ì¶œë ¥

```python
from collections import deque

N, K = map(int, input().split())
nums = tuple(map(int, input().split()))

# ì •ë ¬ëœ ìˆœì—´ ë° ë°©ë¬¸ ìˆœì—´ ì €ì¥
sorted_nums = tuple(sorted(nums))
visit = {nums}

# BFS
Q = deque([[nums[:], 0]])
while Q:
    now, dist = Q.popleft()
    # ì •ë ¬ëœ ìˆœì—´ê³¼ ê°™ë‹¤ë©´ ì¢…ë£Œ
    if now == sorted_nums: exit(print(dist))
    # ê° ìë¦¬ë§ˆë‹¤ ë’¤ì§‘ì€ ë°°ì—´ ìƒì„±
    for i in range(N-K+1):
        next = now[:i] + now[i:i+K][::-1] + now[i+K:]
        if next in visit: continue
        Q.append([next, dist+1])
        visit.add(next)

# Qê°€ ë¹Œ ë•Œê¹Œì§€ ì¢…ë£Œê°€ ì•ˆ ë˜ì—ˆë‹¤ë©´ ì •ë ¬ì´ ë¶ˆê°€ëŠ¥í•œ ê²ƒ
print(-1)
```

#### ğŸ§° ë°±ì¤€ 1450 ëƒ…ìƒ‰ë¬¸ì œ 
> `ì¤‘ê°„ì—ì„œ ë§Œë‚˜ê¸°` ìƒˆë¡œìš´ ë¡œì§ ì´ìš© (ìœ ì‚¬ë¬¸ì œ : ë¶€ë¶„ìˆ˜ì—´ì˜ í•©)
> 1. Nê°œì˜ ë¬¼ê±´ ì¤‘ì—ì„œ ë¬´ê²Œì˜ í•©ì´ Cì´í•˜ì¸ ë§Œí¼ ì„ íƒê°€ëŠ¥
> 2. subSetsum : ë¶€ë¶„ì§‘í•©ì˜ í•©ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
> 3. ë¬¼ê±´ì„ ë‘ ë¶€ë¶„ì§‘í•©ìœ¼ë¡œ ë‚˜ëˆ„ì–´, í•œìª½ ë¶€ë¶„ì§‘í•©(A)ê³¼ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì§‘í•©(B)ì˜ ìš”ì†Œë¥¼ ë¹„êµí•˜ì—¬ ì¡°ê±´ ì¶©ì¡±í•˜ëŠ” ê²½ìš° ê°¯ìˆ˜ ì¹´ìš´íŠ¸
> 4. ë‚˜ë¨¸ì§€ í•œ ì§‘í•©(B)ì€ ì •ë ¬í•˜ê³ , ì´ì§„íƒìƒ‰ì„ í†µí•´ Aì™€ Bì˜ í•©ì´ Cë³´ë‹¤ ì¡ì€ ê²½ìš°ì—ë§Œ Bì˜ ì¸ë±ìŠ¤ë§Œí¼ ê²°ê³¼ê°’ì— ê°€ì‚°
> 5. ì™œëƒí•˜ë©´ ì´ì§„íƒìƒ‰ì´ê¸° ë•Œë¬¸ì—, Cì— ê°€ì¥ ê°€ê¹Œìš´ Bì˜ ì¸ë±ìŠ¤ê°’ì€ ê·¸ ì•„ë˜ì— ìˆëŠ” ì• ë“¤ì€ ëª¨ë‘ í•©í•´ë´¤ì Cë³´ë‹¤ ì‘ê¸° ë•Œë¬¸ì— Bì˜ ì¸ë±ìŠ¤ê°’ì„ ë”í•´ì£¼ë©´ ë¨

```python
N, C = map(int, input().split())
items = list(map(int, input().split()))

# ë¶€ë¶„ì§‘í•©ì˜ í•© ê³„ì‚° í•¨ìˆ˜
def subSetSum(arr):
    part = [0]
    for n in arr: part += [n+x for x in part]
    return part

# ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë¶€ë¶„ì§‘í•©ì˜ í•© ê³„ì‚°
part1 = subSetSum(items[:N//2])
part2 = subSetSum(items[N//2:])
part2.sort()  # ì´ì§„ íƒìƒ‰ì„ ìœ„í•´ ì •ë ¬

# í•œ ë¶€ë¶„ì˜ ë¶€ë¶„ì§‘í•©ì˜ í•©ì„ ë‹¤ë¥¸ ë¶€ë¶„ê³¼ ëŒ€ì¡°í•˜ì—¬ ì¡°ê±´ì— ë§ìœ¼ë©´ ì¹´ìš´íŠ¸í•˜ëŠ” í•¨ìˆ˜
def countPairs(part1, part2, limit, cnt=0):
    for mass in part1:
        if mass > limit: continue
        L, R = 0, len(part2)

        # ê¸°ì¤€ì ì— ë§ëŠ” ë¶€ë¶„ì„ ì°¾ê¸° ìœ„í•œ ì´ë¶„íƒìƒ‰ ë¶€ë¶„
        while L < R:
            M = (L+R)//2
            if part2[M] + mass <= limit:
                L = M+1
            else:
                R = M
        # ì¡°ê±´ì„ ë§ì¶”ëŠ” ë¬´ê²Œê¹Œì§€ ê°œìˆ˜ í•©ì‚°
        cnt += L
    return cnt
print(countPairs(part1, part2, C))
```

#### âš½ ë°±ì¤€ 7576 í† ë§ˆí† 
> `BFS`ë¥¼ ì´ìš© 
> 1. ìµì€ í† ë§ˆí† ë¥¼ ëª¨ë‘ êµ¬í•´ì„œ qì— ë°”ë¡œ ë‹´ì•„ì¤€ë‹¤.
> 2. BFSë¥¼ ëŒë ¤ì„œ, qì—ì„œ ë‚˜ì™€ ë‹¤ìŒ íƒìƒ‰ìœ¼ë¡œ ì´ë™í•  ë•Œ, í˜„ì¬ë³´ë‹¤ cntë¥¼ 1ì¦ê°€ ì‹œì¼œ qì— appendí•œë‹¤.
> 3. ë°˜ë³µë¬¸ì„ íƒˆì¶œí•˜ê³ , 0ì´ ë°œê²¬ë˜ë©´ -1ì„ ì¶œë ¥í•œë‹¤. ì•„ë‹ˆë¼ë©´ cntë¥¼ ì¶œë ¥í•œë‹¤.

```python
from collections import deque

dr = ((1,0),(0,1),(-1,0),(0,-1))
N,M = map(int,input().split()) # N ê°€ë¡œ M ì„¸ë¡œ

tomatoes = [list(map(int,input().split())) for _ in range(M)]
# í† ë§ˆí†  ìœ„ì¹˜ êµ¬í•˜ê¸°
q = deque([])
for i in range(M):
    for j in range(N):
        if tomatoes[i][j] == 1 :
            q.append((i,j,0))
# BFS
while q :
    i,j,cnt = q.popleft()
    for dx,dy in dr :
        di, dj = i+dx, j+dy
        if 0 <= di < M and 0 <= dj < N :
            if tomatoes[di][dj] == 0 :
                tomatoes[di][dj] = 1
                q.append((di,dj,cnt+1))
# 0 ë°œê²¬ ì‹œ -1 ì¶œë ¥ í›„ ì¢…ë£Œ
for i in range(M):
    for j in range(N):
        if tomatoes[i][j]==0:
            exit(print(-1))

# ê·¸ ì™¸ì—ëŠ” ë§ˆì§€ë§‰ì— popëœ cntê°€ ì •ë‹µ
print(cnt)
```

#### ğŸ–Œ ë°±ì¤€ 9465 ìŠ¤í‹°ì»¤ 
> `DP`ë¥¼ ì´ìš©í•œ ìŠ¤í‹°ì»¤
> 1. ìŠ¤í‹°ì»¤ë¼ë¦¬ ì¸ì ‘í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ì™¼ìª½ í•˜ë‹¨ ìŠ¤í‹°ì»¤ì— ëˆ„ì ëœ í•©ê³¼, ì™¼ìª½ í•˜ë‹¨ì˜ ìŠ¤í‹°ì»¤ì˜ ì™¼ìª½ì— ëˆ„ì ëœ í•©ì„ ë¹„êµí•˜ì—¬ DPì— ë‹´ëŠ”ë‹¤.
> 2. ë§ˆì§€ë§‰ì— ëˆ„ì ëœ ìŠ¤í‹°ì»¤ì˜ maxê°’ì„ ì¶œë ¥
```python
import sys
input = sys.stdin.readline

for _ in range(int(input())):
    size = int(input())
    sticker = [[0,0] + list(map(int,input().split())) for _ in range(2)]

    # ëŒ€ê°ì„  í•œì¹¸ ë°˜ëŒ€ or ëŒ€ê° ë‘ì¹¸ ì „ ë°˜ëŒ€

    for j in range(2,size+2):
        for i in range(2) :
            sticker[i][j] += max(sticker[i-1][j-1], sticker[i-1][j-2])
    print(max([max(x) for x in sticker]))
``` 

#### ğŸ™ ë°±ì¤€ 13335 íŠ¸ëŸ­
> ê°„ë‹¨í•œ `êµ¬í˜„` ë¬¸ì œ
> 1. ë‹¤ë¦¬ í•˜ì¤‘ ë‚´ì—ì„œ íŠ¸ëŸ­ì„ ì¶”ê°€í•  ë•Œ, ê²¬ë”œ ìˆ˜ ìˆìœ¼ë©´ íŠ¸ëŸ­ì„ ë‹¤ë¦¬ ìœ„ì— ë„˜ê¸´ë‹¤.
> 2. íŠ¸ëŸ­ë“¤ì´ ì „ë¶€ ì—†ì–´ì§€ê±°ë‚˜, íŠ¸ëŸ­ì´ ë‹¤ ê±´ë„ ë•Œê¹Œì§€ ë°˜ë³µë¬¸ ìˆœíšŒ
> 3. ë°˜ë³µë¬¸ì„ ìˆœíšŒí•˜ì—¬ `temp_sum`ì— ë¬´ê²Œì˜ í•©ì„ ì €ì¥(ì—¬ê¸°ì— ë‹¤ë¦¬ì— ìˆëŠ” íŠ¸ëŸ­ì˜ ë¬´ê²Œí•© ì €ì¥)
> 4. ë°˜ë³µë¬¸ íƒˆì¶œí•˜ë©´ ì‹œê°„ì„ ì¶œë ¥

```python
from collections import deque

# n: íŠ¸ëŸ­ì˜ ìˆ˜, w: ë‹¤ë¦¬ì˜ ê¸¸ì´, L: ë‹¤ë¦¬ì˜ ìµœëŒ€ í•˜ì¤‘
n, w, L = map(int, input().split())

# íŠ¸ëŸ­ì˜ ë¬´ê²Œë¥¼ ì…ë ¥ ë°›ìŒ
trucks = deque(map(int, input().split()))

# ë‹¤ë¦¬ ìœ„ì— ì˜¬ë¼ê°„ íŠ¸ëŸ­ë“¤ì˜ ë¬´ê²Œì˜ í•©ì„ ì €ì¥í•  ë³€ìˆ˜ ì´ˆê¸°í™”
temp_sum = 0

# ë‹¤ë¦¬ ìœ„ì˜ íŠ¸ëŸ­ì„ ë‚˜íƒ€ë‚´ëŠ” deque ì´ˆê¸°í™”
result = deque([0] * w)

# ê²½ê³¼ ì‹œê°„ì„ ë‚˜íƒ€ë‚´ëŠ” ë³€ìˆ˜ ì´ˆê¸°í™”
time = 0

# ëª¨ë“  íŠ¸ëŸ­ì´ ë‹¤ë¦¬ë¥¼ ê±´ë„ ë•Œê¹Œì§€ ë°˜ë³µ
while trucks or sum(result) != 0:
    temp_sum -= result.popleft()  # ë‹¤ë¦¬ë¥¼ ê±´ë„ˆëŠ” íŠ¸ëŸ­ ì¤‘ ê°€ì¥ ë¨¼ì € ë“¤ì–´ê°„ íŠ¸ëŸ­ì˜ ë¬´ê²Œë¥¼ ë¹¼ì¤Œ
    if trucks and temp_sum + trucks[0] <= L:  # ë‹¤ìŒ íŠ¸ëŸ­ì´ ë‹¤ë¦¬ì— ì˜¬ë¼ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
        temp_sum += trucks[0]  # ë‹¤ìŒ íŠ¸ëŸ­ì„ ë‹¤ë¦¬ì— ì˜¬ë¦¬ê³  ë‹¤ë¦¬ ìœ„ íŠ¸ëŸ­ë“¤ì˜ ë¬´ê²Œì˜ í•©ì„ ì—…ë°ì´íŠ¸
        result.append(trucks.popleft())  # ë‹¤ìŒ íŠ¸ëŸ­ì„ ë‹¤ë¦¬ ìœ„ì— ì˜¬ë¦¼
    else:
        result.append(0)  # ë‹¤ìŒ íŠ¸ëŸ­ì´ ì˜¬ë¼ê°€ì§€ ëª»í•˜ë©´ ë‹¤ë¦¬ ìœ„ì—ëŠ” ì•„ë¬´ê²ƒë„ ì˜¬ë¦¬ì§€ ì•ŠìŒ
    time += 1  # ê²½ê³¼ ì‹œê°„ì„ ì¦ê°€
print(time)  # ê±¸ë¦° ì‹œê°„ ì¶œë ¥
```

#### ğŸ‘” ë°±ì¤€ 14567 ì„ ìˆ˜ê³¼ëª©
> `ê·¸ë˜í”„`ì˜ ì—°ê²°ì •ë³´ë¥¼ ì €ì¥í•˜ê³ , ê¹Šì´ë¥¼ êµ¬í•œë‹¤. 
> ê° `ê·¸ë˜í”„`ì˜ ê¹Šì´ë¥¼ ìˆœíšŒí•  ë•Œë§ˆë‹¤ maxê°’ì„ ì €ì¥í•œë‹¤.(ëª¨ë“  ì„ ìˆ˜ê³¼ëª©ì„ ìˆ˜ê°•í•´ì•¼ í•œë‹¤.)
```python
N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
depth = [1] * (N+1)

# ê·¸ë˜í”„ ìƒì„±
for _ in range(M):
    pre, post = map(int, input().split())
    graph[pre].append(post)

# ì§„ì… ì°¨ìˆ˜ ê³„ì‚°
for now in range(1, N+1):
    for next in graph[now]:
        depth[next] = max(depth[next], depth[now] + 1)

print(*depth[1:])

```
> ë‘ë²ˆì§¸ ë°©ë²• : `ìœ„ìƒì •ë ¬` í™œìš©
> 1. `indegree` : ì§„ì…ì°¨ìˆ˜ë¥¼ ì €ì¥
> 2. `result` : ê° ì¸ë±ìŠ¤ì— ìµœëŒ€ ê¹Šì´ë¥¼ ì €ì¥
> 3. `heap` êµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬, ê¹Šì´ê°€ ìµœì†Œì¸ ê²½ìš°ë¥¼ ìš°ì„  íƒìƒ‰
> 4. ìµœì¢…ì ìœ¼ë¡œ, ê²°ê³¼ê°’ ë°˜í™˜(ëª¨ë“  ì§„ì…ì°¨ìˆ˜ ì €ì¥)
```py
from heapq import*

def topological_sort():
    q = []
    result = [0] * (N + 1)

    for vertex in range(1, N + 1):
        if indegree[vertex] == 0:
            heappush(q, (1, vertex))

    while q:
        semester, vertex = heappop(q)
        result[vertex] = semester

        for v in graph[vertex]:
            indegree[v] -= 1
            
            if indegree[v] == 0:
                heappush(q, (semester + 1, v))

    return result

N, M = map(int, input().split())
graph = [[] for _ in range(N + 1)]
indegree = [0] * (N + 1)

for _ in range(M):
    A, B = map(int, input().split())
    graph[A].append(B)
    indegree[B] += 1

result = topological_sort()

for i in result:
    if i:
        print(i, end = ' ')
``` 
---
#### ğŸ“€ ë°±ì¤€ 15565 ê·€ì—¬ìš´ ë¼ì´ì–¸ 
> `ìŠ¬ë¼ì´ë”© ìœˆë„ìš°` í™œìš©
> 1. ë¼ì´ì–¸ ê°¯ìˆ˜ê°€ ì¶©ì¡±ë  ë•Œê¹Œì§€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
> 2. ê°¯ìˆ˜ ì¶©ì¡±ì‹œ, ì˜¤ë¥¸ìª½ í¬ì¸í„° - ì™¼ìª½ í¬ì¸í„° + 1 ê°’ê³¼ ê¸°ì¡´ ìµœì†Œê°’ì„ ë¹„êµí•˜ì—¬, ìµœì†Œ ê¸¸ì´ë¥¼ ì €ì¥í•´ì£¼ê³ , ì™¼ìª½ í¬ì¸í„°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•œë‹¤.
> 3. ê·¸ë¦¬ê³  ë‹¤ì‹œ ê°¯ìˆ˜ê°€ ì¶©ì¡±ë  ë•Œê¹Œì§€ ìœ„ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.
> 4. ê¸¸ì´ Në§Œí¼ ëª¨ë‘ ìˆœíšŒí•  ë•Œ ìµœì†Œ ê¸¸ì´ë¥¼ ë°˜í™˜í•œë‹¤.

```python
N, K = map(int, input().split())
doll = list(map(int, input().split()))

cnt = L = R = 0
ans = N + 1

# ì²« ë²ˆì§¸ ì¸í˜•ì´ ë¼ì´ì–¸ì´ë©´ ì¹´ìš´íŠ¸ + 1
if doll[L] == 1: cnt += 1

# ì˜¤ë¥¸ìª½ í¬ì¸í„°ê°€ ëê¹Œì§€ ê°ˆ ë•Œê¹Œì§€ ë°˜ë³µ
while R < N:
    # ì¡°ê±´ ì¶©ì¡± ì‹œ
    if cnt == K:
        ans = min(ans, R-L+1)  # ê¸°ë¡
        cnt -= (doll[L] == 1)
        L += 1
    # ì¡°ê±´ ë¯¸ì¶©ì¡± ì‹œ
    else:
        R += 1
        cnt += (R < N and doll[R] == 1)

print(ans if ans < N+1 else -1)
```

#### ğŸ§â€â™€ï¸ ë°±ì¤€ 16562 ì¹œêµ¬ë¹„
> `Kruskal` ì•Œê³ ë¦¬ì¦˜ í™œìš©
> 1. ì¹œí•œì¹œêµ¬ë¼ë¦¬ `union`ê³¼ `find`ë¡œ ë¬¶ì–´ì¤€ë‹¤.
> 2. ê°™ì€ ë¬´ë¦¬ë³„ ê°€ê²©ì„ `sep_dict`ì— ì €ì¥í•œë‹¤.
> 3. ë¬´ë¦¬ë³„ë¡œ ë°˜ë³µí•˜ì—¬ ìµœì†Œê°’ì„ ê²°ê³¼ê°’ì— ì €ì¥í•œë‹¤.
```python
# ë¶€ëª¨ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜
def find_parent(parent, x):
    if parent[x] != x:  # í˜„ì¬ ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œê°€ ìê¸° ìì‹ ì´ ì•„ë‹ˆë©´
        parent[x] = find_parent(parent, parent[x])  # ë¶€ëª¨ ë…¸ë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì°¾ì•„ì„œ ê²½ë¡œ ì••ì¶•
    return parent[x]  # ë¶€ëª¨ ë…¸ë“œ ë°˜í™˜

# ë‘ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜
def union(parent, a, b):
    a = find_parent(parent, a)  # ë…¸ë“œ aì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ì°¾ìŒ
    b = find_parent(parent, b)  # ë…¸ë“œ bì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ì°¾ìŒ
    if a < b:  # ë‘ ë…¸ë“œì˜ ë¶€ëª¨ê°€ ë‹¤ë¥´ë©´
        parent[b] = a  # bì˜ ë¶€ëª¨ë¥¼ aë¡œ ì„¤ì •
    else:
        parent[a] = b  # aì˜ ë¶€ëª¨ë¥¼ bë¡œ ì„¤ì •

# ì…ë ¥ê°’ ë°›ìŒ: Nì€ ì¹œêµ¬ì˜ ìˆ˜, Mì€ ì¹œêµ¬ ê´€ê³„ì˜ ìˆ˜, këŠ” ì¹œêµ¬ë“¤ì´ ëª¨ì´ëŠ”ë° ë“œëŠ” ëˆ
N, M, k = map(int, input().split())

# ì¹œêµ¬ë“¤ì˜ ê°€ê²© ì •ë³´ë¥¼ ë°›ìŒ
friends_cost = list(map(int, input().split()))

# ê° ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´ ì´ˆê¸°í™”(ì²˜ìŒì€ ìê¸°ê°€ ìê¸° ë¬´ë¦¬ì˜ ëŒ€í‘œë…¸ë“œ)
parent = [i for i in range(N + 1)]

# ì¹œêµ¬ ê´€ê³„ë¥¼ ì…ë ¥ë°›ê³  ë‘ ì¹œêµ¬ë¥¼ ê°™ì€ ë¬´ë¦¬ë¡œ í•©ì¹¨
# í–¥í›„ ê°€ì¥ ë‚®ì€ ë¹„ìš©ì´ ë“œëŠ” ì¹œêµ¬ì—ê²Œë§Œ ë¹„ìš©ì§€ë¶ˆ ì˜ˆì •
for _ in range(M):
    v, w = map(int, input().split())
    union(parent, v, w)

# ë¶€ëª¨ ë…¸ë“œë³„ë¡œ ì¹œêµ¬ë“¤ì˜ ê°€ê²©ì„ ì €ì¥í•˜ëŠ” ì‚¬ì „ ì´ˆê¸°í™”
sep_dict = {i: set() for i in range(1, max(parent) + 1)}

# ì¹œí•œ ì¹œêµ¬ë¼ë¦¬ ë¬¶ì–´ sep_dictì— ì €ì¥
for i in range(1, N + 1):
    sep_dict[find_parent(parent, i)].add(friends_cost[i - 1])

# ê° ì¹œêµ¬ë¬´ë¦¬ë³„ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•˜ê³  ê²°ê³¼ì— ë”í•¨
result = sum(map(lambda x:min(x) if x else 0, sep_dict.values()))

# ì†Œìš”ë¹„ìš©ì´ ë‚´ê°€ ê°€ì§„ ëˆ kë¥¼ ì´ˆê³¼í•˜ëŠ”ì§€ í™•ì¸í•˜ê³  ì¶œë ¥
print(result if result <= k else 'Oh no')
```
> `Prim`ì„ í™œìš©í•œ ë¬¸ì œí’€ì´
> 1. `graph`ì— ì¹œêµ¬ë¹„ìš©ì„ ì €ì¥í•œë‹¤.
> 2. ë‹¨, ì—°ê²°ëœ ê³³ì€ 0ìœ¼ë¡œ ì €ì¥í•œë‹¤.
> 3. 0ì„ ì‹œì‘ì ìœ¼ë¡œ í•˜ì—¬ `ê·¸ë¦¬ë””`í•˜ê²Œ ë‚®ì€ ë¹„ìš©ì„ ì „ë¶€ í•©í•´ì¤€ë‹¤.
> 4. ê²°ê³¼ê°’ì„ ë°˜í™˜í•œë‹¤.
```py
from heapq import *

def prim(start):
    connected = {start}
    unconnected = [(w, v) for w, v in graph[start]]
    heapify(unconnected)
    cost = 0
    while unconnected:
        weight, vertex = heappop(unconnected)
        if vertex in connected:
            continue
        connected.add(vertex)
        cost += weight
        for w, v in graph[vertex]:
            if v in connected:
                continue
            heappush(unconnected, (w, v))
    return cost

N, M, k = map(int, input().split())
list_ = [0] + list(map(int, input().split()))
graph = [[] for _ in range(N + 1)]

for i in range(1, N + 1):
    graph[0].append((list_[i], i))
    graph[i].append((list_[i], 0))

for _ in range(M):
    v, w = map(int, input().split())
    graph[v].append((0, w))
    graph[w].append((0, v))

result = prim(0)
if result > k:print('Oh no')
else:print(result)
```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 20529 ê°€ì¥ ê°€ê¹Œìš´ ì„¸ ì‚¬ëŒì˜ ì‹¬ë¦¬ì  ê±°ë¦¬
> `ë¹„ë‘˜ê¸°ì§‘ ì›ë¦¬`ì™€ `combinations`ë¥¼ ì´ìš©
> 1. ì„¸ ì‚¬ëŒì˜ ì‹¬ë¦¬ì ê±°ë¦¬ë¥¼ ìŸ¤ê¸° ë•Œë¬¸ì— ì„¸ ì‚¬ëŒì´ ë™ì¼í•œ MBTIë©´ ë¬´ì¡°ê±´ ê°’ì´ 0ì„ --> Nì´ 33ì´ë©´ ë¬´ì¡°ê±´ ê²¹ì¹˜ëŠ” ì„¸ì‚¬ëŒì´ ì¡´ì¬
> 2. `combinations`ì—ì„œ ì„¸ ì‚¬ëŒì„ ì¡°íšŒí•˜ì—¬ MBTI ë™ì¼ì„± íŒë‹¨í•˜ì—¬ ì¼ì¹˜ì—¬ë¶€ ìµœì†Œê°’ ë°˜í™˜(`ë¸Œë£¨íŠ¸í¬ìŠ¤`)
```python
from itertools import combinations

for _ in range(int(input())):
    N, ans = int(input()), 8
    MBTI = input().split()

    # Nì´ 32ë³´ë‹¤ í¬ë©´ ì ì–´ë„ 3ê°œì¸ mbtiê°€ ìˆìœ¼ë¯€ë¡œ ìµœì†Œ ê±°ë¦¬ëŠ” 0
    if N > 32: print(0); continue

    # ì£¼ì–´ì§„ MBTIì¤‘ì—ì„œ ì›ì†Œ ê°œìˆ˜ê°€ 3ê°œì¸ ì¡°í•© ê³¨ë¼ëƒ„
    for a in set(combinations(MBTI, 3)):
        cnt = 0

        # ê° ìë¦¬ë§ˆë‹¤ set ê¸€ì ê°œìˆ˜ë¡œ ë™ì¼ ë¬¸ì íŒë³„
        for b in map(set, zip(*a)):
            if len(b) == 2: cnt += 2

        # ë‹µê³¼ ë¹„êµ í›„ ìµœì†Ÿê°’ ì„ ì •
        ans = min(ans, cnt)

    print(ans)

```

#### â¤ï¸â€ğŸ”¥ SWEA 2477 ì°¨ëŸ‰ì •ë¹„ì†Œ
> `ì‹œë®¬ë ˆì´ì…˜` + `êµ¬í˜„` ë¬¸ì œ
> 1. `Guest`ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ì—¬, ë³´ë‹¤ ê°€ë…ì„±ì¢‹ê²Œ ë¬¸ì œí’€ì´
> 2. ì •ë¹„ì°½êµ¬ â†’ ì •ë¹„ëŒ€ê¸° â†’ ì ‘ìˆ˜ì°½êµ¬ â†’ ì ‘ìˆ˜ëŒ€ê¸° ìˆœìœ¼ë¡œ ë°˜ë³µë¬¸ ìˆœíšŒ
> 3. ëª¨ë“  `Guest`ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìˆœíšŒí•˜ì—¬ ìƒì–´ë²„ë¦° ì§€ê°‘ ê³ ê°ê³¼ ê°™ì€ ê²½ìš° ê²°ê³¼ê°’ ì¶”ê°€
```py
from collections import deque

class Guest:
    def __init__(self, pk):
        self.pk = pk
        self.numA = 0
        self.numB = 0
        self.time = 0
        self.end = False

def find(arr, V):
    try: return arr.index(V)
    except ValueError: return -1

for tc in range(int(input())):
    N, M, K, A, B = map(int, input().split())  # ì ‘ìˆ˜ ì°½êµ¬ ìˆ˜, ì •ë¹„ ì°½êµ¬ ìˆ˜, ë°©ë¬¸ ê³ ê° ìˆ˜, íƒ€ê²Ÿ ì ‘ìˆ˜ ì°½êµ¬, íƒ€ê²Ÿ ì •ë¹„ ì°½êµ¬
    timeA = list(map(int, input().split()))  # ì ‘ìˆ˜ ì†Œìš” ì‹œê°„ : Nê°œ
    timeB = list(map(int, input().split()))  # ì •ë¹„ ì†Œìš” ì‹œê°„ : Mê°œ
    timeT = list(map(int, input().split()))  # ê³ ê° ë°©ë¬¸ ì‹œê°„ : Kê°œ

    deskA = [False] * N; waitA = deque([])  # ì ‘ìˆ˜ ì°½êµ¬ ë° ëŒ€ê¸°
    deskB = [False] * M; waitB = deque([])  # ì •ë¹„ ì°½êµ¬ ë° ëŒ€ê¸°

    timeT = deque(timeT)
    ans, num = 0, 1
    guests = []

    for t in range(5000):
        # ì •ë¹„ ì°½êµ¬
        for j, desk in enumerate(deskB):
            if not(desk and not desk.time): continue

            # ì •ë¹„ ëŒ€ê¸° ì¸ì› ì •ë¹„ ì°½êµ¬ ì´ë™
            if waitB:
                deskB[j] = waitB.popleft()
                deskB[j].time = timeB[j]
                deskB[j].numB = j
            else:
                deskB[j] = False
            # ì¢…ë£Œ ì¡°ê±´ ì¶”ê°€
            desk.end = True

        # ì ‘ìˆ˜ ì°½êµ¬
        for i, desk in enumerate(deskA):
            if not desk or desk.time > 0: continue

            # ì ‘ìˆ˜ ì™„ë£Œì ì •ë¹„ ì°½êµ¬ ë˜ëŠ” ì •ë¹„ ëŒ€ê¸° ì´ë™
            j = find(deskB, False)
            if j > -1:
                deskB[j] = desk
                deskB[j].time = timeB[j]
                deskB[j].numB = j
            else:
                waitB.append(desk)

            # ì ‘ìˆ˜ ëŒ€ê¸° ì¸ì› ì ‘ìˆ˜ ì°½êµ¬ ì´ë™
            if waitA:
                deskA[i] = waitA.popleft()
                deskA[i].time = timeA[i]
                deskA[i].numA = i
            else:
                deskA[i] = False

        # ì •ë¹„ì†Œ ë°©ë¬¸
        while timeT and timeT[0] == t:
            guests.append(Guest(num))
            # ë°©ë¬¸ì ì ‘ìˆ˜ ì°½êµ¬ ë˜ëŠ” ì ‘ìˆ˜ ëŒ€ê¸° ì´ë™
            i = find(deskA, False)
            if i > -1:
                deskA[i] = guests[-1]
                deskA[i].time = timeA[i]
                deskA[i].numA = i
            else:
                waitA.append(guests[-1])

            num += 1
            timeT.popleft()

        # ì‹œê°„ ê²½ê³¼
        flag = 0
        for guest in guests:
            guest.time -= 1
            if guest.end: flag += 1

        if flag == K: break

    # ì§€ê°‘ ë¶„ì‹¤ì ì²´í¬
    for guest in guests:
        if guest.numA == A-1 and guest.numB == B-1:
            ans += guest.pk

    print(f'#{tc+1} {ans if ans else -1}')
```
