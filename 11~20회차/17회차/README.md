## Algorithm Study 17íšŒì°¨ íšŒì˜ (24.6.8.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 6ì›” 8ì¼ ì¼ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 6ì›” 15ì¼ í† ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ì†¡ì‚¼ 2ì¸µ

    ë‹¤. ë³€ê²½ì‚¬í•­
        1. ë¬¸ì œì„ ì • : ì¸ë‹¹ ê° 1ë¬¸ì œ (ì´ 7ë¬¸ì œ, ë³€ë™ì—†ìŒ)
        2. ë¬¸ì œ ë¸Œë¦¬í•‘ ë°©ì‹ ë³€ê²½ 
            - â‘  ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ íŒŒì´ì¬ìœ¼ë¡œ ë¼ì´ë¸Œ ì½”ë”©(ë‹¨, ì´ê²½ìš° ì¶”ê°€ë¡œ ìë°”ë¡œ ë¸Œë¦¬í•‘í•´ë„ ë¨)
            - â‘¡ ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ ì™¸ì—ë„ ë‹¤ë¥¸ ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œ í•˜ë‚˜ ë” ë¸Œë¦¬í•‘ ì˜ˆì •ì´ë©°, ê·¸ ì¶”ê°€ ë¬¸ì œ ì„ ì • ë°©ì‹ì€ ìê¸° "ì•"ì— ìˆëŠ” ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œë¡œ ì •í•˜ì—¬ ì¶”ê°€ë¡œ ë¸Œë¦¬í•‘ 
            - ìˆœì„œ : ì´ì°½í˜¸ - ìµœì§€ìš° - ì´ê¶Œë¯¼ - ë°•ë™í˜„ - ì´ìƒí˜„ - ìœ¤ì˜ˆë¦¬ - ì„ê²½íƒœ  (ìˆœì„œëŠ” ë§¤ë²ˆ ëœë¤ìœ¼ë¡œ ë³€ê²½ ì˜ˆì •) 
            - â‘¢ í•œë²ˆì— 2ê°œë¥¼ ë‹¤ ë¸Œë¦¬í•‘í•˜ì§€ ì•Šê³ , ì¶”ê°€ ë¬¸ì œëŠ” ë‹¤ì‹œ í•œë²ˆ ë¡œí…Œì´ì…˜ì„ ëŒ ì˜ˆì •.
    
    ë¼. ìœ ì§€ì‚¬í•­
        - ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        - ë¹„ëŒ€ë©´, ëŒ€ë©´ 1íšŒì”©. 1ì£¼ì¼ë§ˆë‹¤ í•œë²ˆ

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ìœ„ ë³€ê²½ì‚¬í•­ ì°¸ê³ 

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92343 ì–‘ê³¼ ëŠ‘ëŒ€(2022 KAKAO BLIND RECRUITMENT, Lv.3) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 1079 ë§ˆí”¼ì•„(ê³¨ë“œ 2) 
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 13904 ê³¼ì œ(ê³¨ë“œ 3)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 2812 í¬ê²Œ ë§Œë“¤ê¸°(ê³¨ë“œ 3)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 17686 íŒŒì¼ëª… ì •ë ¬(2028 KAKAO BLIND RECURITMENT, Lv.2)
   ###### 6. ì§€ìš°
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92345 - ì‚¬ë¼ì§€ëŠ” ë°œíŒ (2022 KAKAO BLIND RECRUITMENT, Lv.3)
   ###### 7. ê¶Œë¯¼
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 60057 - ë¬¸ìì—´ ì••ì¶• (2020 KAKAO BLIND RECRUITMENT, Lv.2)

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 2344 ê±°ìš¸(ê³¨ë“œ 4) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 11779 ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°(ê³¨ë“œ 3) 
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 2437 ì €ìš¸(ê³¨ë“œ 2)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 12689 ë®¤íƒˆë¦¬ìŠ¤í¬(ê³¨ë“œ 4)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92335 kì§„ìˆ˜ì—ì„œ ì†Œìˆ˜ ê°œìˆ˜ êµ¬í•˜ê¸°(Lv.2)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 1339 ë‹¨ì–´ ìˆ˜í•™ (ê³¨ë“œ 4)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 24533 íŒ°ë¦°ë“œë¡¬ ê²Œì„(ê³¨ë“œ 4)

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1079 ë§ˆí”¼ì•„
> ë°±íŠ¸ë˜í‚¹ì„ í™œìš©í•˜ì—¬ ë¬¸ì œ í’€ì´
> `mapia` í•¨ìˆ˜ : ëª‡ëª… ë‚¨ì•˜ëŠ”ì§€ì— ë”°ë¼ì„œ ë§ˆí”¼ì•„ê°€ ë³´ë‚¼ ìµœëŒ€ ë°¤ìˆ˜ ë„ì¶œ
> ë‚¨ëŠ” ë‚ ì´ ì—†ê±°ë‚˜, ë§ˆí”¼ì•„ í˜¼ì ì‚´ì•„ë‚¨ì•˜ìœ¼ë©´ ë°±íŠ¸ë˜í‚¹
> visited ëŒ€ì‹  ìœ ì£„ì§€ìˆ˜ì™€ ì‚´ì•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë°±íŠ¸ë˜í‚¹

```python
import sys
sys.setrecursionlimit(10 ** 8)
input = sys.stdin.readline

n = int(input())
criminal = list(map(int, input().split()))

R = [
    list(map(int, input().split()))
    for _ in range(n)
]

eunjin = int(input())
is_alive = [True] * n

ans = 0
flag = False
def mafia(remain, nights):
    global ans, flag

    if flag:
        return

    ans = max(ans, nights)

    if remain == 0:
        return

    if remain == 1 and is_alive[eunjin]:
        flag = True
        return

    # ì§ìˆ˜ëª…ì´ ë‚¨ì•˜ìœ¼ë©´ ë°¤ì´ë‹¤.
    if remain % 2 == 0:
        for i in range(n):
            if not is_alive[i] or i == eunjin:
                continue
            is_alive[i] = False
            # ì‚´ì•„ìˆëŠ” ì‚¬ëŒë“¤ì˜ ìœ ì£„ ì§€ìˆ˜ ë³€ê²½
            for j in range(n):
                if not is_alive[j]:
                    continue
                criminal[j] += R[i][j]
            mafia(remain - 1, nights + 1)
            # ì›ìƒ ë³µêµ¬
            for j in range(n):
                if not is_alive[j]:
                    continue
                criminal[j] -= R[i][j]
            is_alive[i] = True

    # í™€ìˆ˜ëª…ì´ ë‚¨ì•˜ìœ¼ë©´ ë‚®ì´ë‹¤.
    else:
        max_criminal = -1
        index = -1

        for i, c in enumerate(criminal):
            if not is_alive[i]:
                continue

            if max_criminal < c:
                index = i
                max_criminal = c

        if index == eunjin:
            return

        is_alive[index] = False
        mafia(remain - 1, nights)
        is_alive[index] = True

mafia(n, 0)

print(ans)
```
#### ğŸ§° ë°±ì¤€ 2812 í¬ê²Œ ë§Œë“¤ê¸°
> 1. ì£¼ì–´ì§„ numberì—ì„œ ìˆ˜ë¥¼ ê³„ì† ë½‘ì•„ stackì— ë„£ëŠ”ë‹¤
> 2. ë„£ì„ ë•Œë§ˆë‹¤ ê°¯ìˆ˜ë¥¼ ì²´í¬í•˜ë©°, ë§Œì•½ ë§ˆì§€ë§‰ ì›ì†Œê°€ ìƒˆ ìˆ«ìë³´ë‹¤ ì‘ì€ ê²½ìš° popí•œë‹¤. 
> 3. ë§Œì•½ ì „ë¶€ ë½‘ì•„ë‚´ì§€ ëª»í–ˆë‹¤ë©´, ì²˜ìŒë¶€í„° Kê°œ ë§Œí¼ë§Œ ì¶”ë ¤ë‚¸ë‹¤. 

```python
import sys
sys.stdin = open('input.txt')

N, K = map(int,input().split())
number = input().strip()

num_to_remove = K
stack = []

for digit in number:
    if num_to_remove and stack and stack[-1] <digit:
        stack.pop()
        num_to_remove-=1
    stack.append(digit)

if num_to_remove >0:
    stack = stack[:-num_to_remove]

print(''.join(stack))
```

#### âš½ ë°±ì¤€ 13904 ê³¼ì œ
> 1. wì˜ ìµœëŒ€í™ì„ êµ¬ì„±í•œë‹¤.
> 2. popì„ í–ˆì„ ë•Œ, í•´ë‹¹ ë‚¨ì€ ì¼ìì— ìš°ì„ ì ìœ¼ë¡œ ê°’ì„ ë„£ëŠ”ë‹¤. ë‹¨, í•´ë‹¹ ì—´ì´ ì°¨ìˆì„ ê²½ìš°ì—ëŠ” í•œì¹¸ì”© ë‚´ë ¤ì˜¤ë©´ì„œ ì±„ìš´ë‹¤.
> 3. ì „ì¹¸ì´ ì°¨ë©´ ê·¸ í•©ì„ ë„ì¶œí•œë‹¤.

```python
import sys
from heapq import *

sys.stdin = open('input.txt')
N = int(input())

heap = []
for i in range(N):
    d,w = map(int,input().split())
    heappush(heap,(-w,d))
result = [0] * (N+1)

while heap:
    now, day = heappop(heap)
    for i in range(min(day,N),0,-1):
        if result[i] == 0:
            result[i] = -now
            break
print(sum(result))
```

#### ğŸ–Œ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 17686 íŒŒì¼ëª… ì •ë ¬
> 1. ì •ê·œí‘œí˜„ì‹ì„ ì´ìš©(([0-9]+) : ìˆ«ì í•˜ë‚˜ì´ìƒì„ í¬í•¨í•˜ëŠ”ì§€ ì—¬ë¶€, ê´„í˜¸ë¥¼ ì“°ê³  splitì— ë„£ìœ¼ë©´ ê·¸ê²ƒê¹Œì§€ í¬í•¨í•´ì„œ ë¶„í• )
> 2. í—¤ë”ë¶€ë¶„ì„ ê¸€ìë¡œ, ìˆ«ìë¶€ë¶„ì„ ì •ìˆ˜ë¡œ ë³€í™˜í•˜ì—¬ ì •ë ¬í•œë‹¤.

```python
import re

def solution(files):
    temp = [re.split(r"([0-9]+)", s) for s in files]

    sort = sorted(temp, key=lambda x: (x[0].lower(), int(x[1])))

    return [''.join(s) for s in sort]
``` 

#### ğŸ™ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 72411 ë©”ë‰´ë¦¬ë‰´ì–¼
> 1. courseì—ì„œ ê° ìš”ë¦¬ì˜ ì¡°í•©ì„ order_dictì— ì €ì¥í•œë‹¤.
> 2. ê·¸ë¦¬ê³  ì¡°í•©ì˜ ê°¯ìˆ˜ì˜ ìµœëŒ€ì¹˜ë¥¼ max_lenì— ì €ì¥í•œë‹¤.
> 3. ê·¸ ì¡°í•©ì˜ ê°¯ìˆ˜ê°€ 2ì´ìƒì¸ ê²ƒë“¤ë§Œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ resultì— ì €ì¥í•œë‹¤.
> 4. ê±°ê¸°ì„œ ê° ì¡°í•©ì˜ ê°¯ìˆ˜ê°€ max_lenì— ì €ì¥ëœ ê°¯ìˆ˜ì™€ ì¼ì¹˜í•œê²ƒë§Œ ë³„ë„ì˜ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•˜ì—¬ ì¶œë ¥í•œë‹¤.

```python
from itertools import combinations

def solution(orders, course):
    order_dict = {}
    max_len = {i: 0 for i in course}
    for length in course:
        for cook in orders:
            for a in combinations(cook, length):
                b = ''.join(sorted(a))
                if b not in order_dict:
                    order_dict[b] = 1
                else:
                    order_dict[b] += 1
                    lens = len(b)
                    if max_len[lens] < order_dict[b]:
                        max_len[lens] = order_dict[b]

    result = sorted(filter(lambda x: order_dict[x] >= 2, order_dict.keys()))

    total_result = []
    for i in result:
        if max_len[len(i)] == order_dict[i]:
            total_result.append(i)
    return total_result
```

#### ğŸ‘” í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 60057 ë¬¸ìì—´ ì••ì¶•
> 1. ê²¹ì¹˜ëŠ” ê¸€ììˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ì²©ë°˜ë³µë¬¸ì„ ìˆ˜í–‰í•œë‹¤.
> 2. tempëŠ” ë°˜ë³µ ê¸°ì¤€ì´ ë˜ëŠ” ê¸€ìë“¤ì´ê³ , cntëŠ” ë°˜ë³µ íšŸìˆ˜ì´ë‹¤. 
> 3. ë§Œì•½ ë°˜ë³µë˜ë©´ compressì— íšŸìˆ˜ì™€ ê·¸ ë¬¸ìì—´ì„ ì ê³ , tempë¥¼ ê°±ì‹ í•œë‹¤.
> 4. ë°˜ë³µë¬¸ì„ ì¢…ë£Œí–ˆì„ ë•Œ, resultì— ìµœì†Œì˜ ê¸¸ì´ë¥¼ ê°±ì‹ í•œë‹¤.

```python
def solution(s):
    result = float('inf')
    for i in range(1,len(s)+1):
        compress='';temp=s[:i];cnt=1
        for j in range(i,len(s)+i,i):
            if temp ==s[j:i+j]:
                cnt+=1
            else:
                if cnt !=1:
                    compress += f'{cnt}{temp}'
                else:
                    compress += temp
                temp = s[j:i+j]
                cnt=1
        result = min(result,len(compress))
    return result
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92343 ì–‘ê³¼ ëŠ‘ëŒ€
> 1. graphë¥¼ ë§Œë“¤ì–´ ê° ì–‘ê³¼ ëŠ‘ëŒ€ì˜ ì—°ê²°ì •ë³´ë¥¼ ì €ì¥í•œë‹¤.
> 2. `DFS`ë¥¼ í†µí•´ ìµœëŒ€í•œ ëŠ‘ëŒ€ì—ê²Œ ì•ˆì¡ì•„ ë¨¹íŒ ì–‘ì˜ ê°¯ìˆ˜ë¥¼ êµ¬í•œë‹¤.
> 3. ë‹¤ìŒ ë…¸ë“œê°€ ì–‘ì¸ ë…¸ë“œì™€ ëŠ‘ëŒ€ì¸ ë…¸ë“œë¥¼ ë‚˜ëˆ ì„œ dfsë¥¼ ìˆ˜í–‰í•˜ê³ , ì–‘ì´ ë” ì ì€ ê²½ìš°ì—ëŠ” ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤.
> 4. ìµœëŒ€í•œ ì–‘ì˜ ê°¯ìˆ˜ë¥¼ ê°±ì‹ í•œë‹¤.

```py
from collections import deque,defaultdict

def solution(info,edges):
    graph = defaultdict(list)

    for parent,child in edges:
        graph[parent].append(child)

    max_sheep = 0

    def dfs(sheep,wolf,current,path):
        nonlocal max_sheep
        max_sheep = max(max_sheep,sheep)

        for node in path:
            for next_node in graph[node]:
                if next_node not in path:
                    if info[next_node]==0:
                        dfs(sheep+1,wolf,current,path|{next_node})
                    else:
                        if sheep > wolf + 1:
                            dfs(sheep,wolf+1,current,path|{next_node})

    dfs(1,0,0,{0})

    return max_sheep
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92345 ì‚¬ë¼ì§€ëŠ” ë²ŒíŒ
> 1. ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ê³¼ ë³´ë“œê°€ ìˆëŠ” ê³³ì—ë§Œ ë°©ë¬¸í•œë‹¤.
> 2. ì°¨ë¡€ë¥¼ ë²ˆê°ˆì•„ê°€ë©´ì„œí•  ë•Œ, ìœ„ì¹˜ë¥¼ ë°˜ëŒ€ë¡œ í•˜ë©´ì„œ ë°œíŒì„ ì´ë™í•œë‹¤.
> 3. ë” ì´ìƒ ê°ˆê³³ì´ ì—†ìœ¼ë©´, result[0]ê°€ falseë©´ ì´ê¸¸ìˆ˜ ìˆê³ , trueë©´ ì§„ë‹¤. ê·¸ ë‹¹ì‹œì˜ turnì„ ë°˜í™˜í•œë‹¤.

```py
dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]
INF = 987654321


def solution(board, aloc, bloc):
    return solve(board, aloc[0], aloc[1], bloc[0], bloc[1])[1]


def in_range(board, y, x):
    if y < 0 or y >= len(board) or x < 0 or x >= len(board[0]):
        return False
    return True


def is_finished(board, y, x):
    for i in range(4):
        ny = y + dy[i]
        nx = x + dx[i]
        if in_range(board, ny, nx) and board[ny][nx]:
            return False
    return True


def solve(board, y1, x1, y2, x2):
    # can_win, turn
    if is_finished(board, y1, x1):
        return [False, 0]

    # ì„œë¡œ ë‘ ìœ„ì¹˜ê°€ ê°™ì„ ë•Œ ì´ë²ˆ í„´ì— ì›€ì§ì´ë©´ ë¬´ì¡°ê±´ ì´ê¸°ë¯€ë¡œ
    if y1 == y2 and x1 == x2:
        return [True, 1]

    min_turn = INF
    max_turn = 0
    can_win = False

    # dfs
    for i in range(4):
        ny = y1 + dy[i]
        nx = x1 + dx[i]
        if not in_range(board, ny, nx) or not board[ny][nx]:
            continue

        board[y1][x1] = 0
        result = solve(board, y2, x2, ny, nx)  # ì°¨ë¡€ê°€ ë°”ë€Œê¸° ë•Œë¬¸ì— ìœ„ì¹˜ë¥¼ ë°”ê¿”ì¤€ë‹¤.
        board[y2][x2] = 1

        # ì´ ì‹œì ì—ì„œëŠ” result[0]ì´ Falseì—¬ì•¼ë§Œ í˜„ì¬ í„´ì—ì„œ ë‚´ê°€ ì´ê¸¸ ìˆ˜ ìˆë‹¤.
        if not result[0]:
            can_win = True
            min_turn = min(min_turn, result[1])
        elif not can_win:
            max_turn = max(max_turn, result[1])

    turn = min_turn if can_win else max_turn

    return [can_win, turn + 1]

```
