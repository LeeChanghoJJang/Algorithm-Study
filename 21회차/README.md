## Algorithm Study 20íšŒì°¨ íšŒì˜ (24.6.29.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 7ì›” 6ì¼ í† ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 7ì›” 14ì¼ ì¼ìš”ì¼ ì˜¤í›„ 7ì‹œ  
        - ë°©ì‹ : ì†¡ì‚¼ 2ì¸µ íšŒì˜ì‹¤

    ë‹¤. ë³€ê²½ì‚¬í•­
        1. ë¬¸ì œì„ ì • : ì¸ë‹¹ ê° 1ë¬¸ì œ (ì´ 7ë¬¸ì œ, ë³€ë™ì—†ìŒ)
        2. ë¬¸ì œ ë¸Œë¦¬í•‘ ë°©ì‹ ë³€ê²½ 
            - â‘  ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ íŒŒì´ì¬ìœ¼ë¡œ ë¼ì´ë¸Œ ì½”ë”©(ë‹¨, ì´ê²½ìš° ì¶”ê°€ë¡œ ìë°”ë¡œ ë¸Œë¦¬í•‘í•´ë„ ë¨)
            - â‘¡ ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œ ì™¸ì—ë„ ë‹¤ë¥¸ ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œ í•˜ë‚˜ ë” ë¸Œë¦¬í•‘ ì˜ˆì •ì´ë©°, ê·¸ ì¶”ê°€ ë¬¸ì œ ì„ ì • ë°©ì‹ì€ ìê¸° "ì•"ì— ìˆëŠ” ì‚¬ëŒì´ ì„ ì •í•œ ë¬¸ì œë¡œ ì •í•˜ì—¬ ì¶”ê°€ë¡œ ë¸Œë¦¬í•‘ 
            - ìˆœì„œ : ì„ê²½íƒœ - ì´ê¶Œë¯¼ - ì´ì°½í˜¸ - ì´ìƒí˜„ - ìµœì§€ìš° - ìœ¤ì˜ˆë¦¬ - ë°•ë™í˜„ (ìˆœì„œëŠ” ë§¤ë²ˆ ëœë¤ìœ¼ë¡œ ë³€ê²½ ì˜ˆì •) 
            - â‘¢ í•œë²ˆì— 2ê°œë¥¼ ë‹¤ ë¸Œë¦¬í•‘í•˜ì§€ ì•Šê³ , ì¶”ê°€ ë¬¸ì œëŠ” ë‹¤ì‹œ í•œë²ˆ ë¡œí…Œì´ì…˜ì„ ëŒ ì˜ˆì •.
    
    ë¼. ìœ ì§€ì‚¬í•­
        - ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        - ë¹„ëŒ€ë©´, ëŒ€ë©´ 1íšŒì”©. 1ì£¼ì¼ë§ˆë‹¤ í•œë²ˆ

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ìœ„ ë³€ê²½ì‚¬í•­ ì°¸ê³ 

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 1423 ì›ìˆ­ì´ í‚¤ìš°ê¸°(ê³¨2)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 17144 ë¯¸ì„¸ë¨¼ì§€ ì•ˆë…•!(ê³¨4)
   ###### 3. ê²½íƒœ
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 250136 ì„ìœ ì‹œì¶” (Lv.2)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 3190 ë±€(ê³¨4)
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 1829 ì¹´ì¹´ì˜¤ í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶(Lv.2)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 16724 í”¼ë¦¬ë¶€ëŠ” ì‚¬ë‚˜ì´(ê³¨3)
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 14938 ì„œê°•ê·¸ë¼ìš´ë“œ(ê³¨4)

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 12015 ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´2(ê³¨2)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 2096 ë‚´ë ¤ê°€ê¸°(ê³¨ 5)
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 14462 ì†Œê°€ ê¸¸ì„ ê±´ë„ˆê°„ ì´ìœ  8 (ê³¨3)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 2023 ì‹ ê¸°í•œ ì†Œìˆ˜(ê³¨5)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 29703 í­ê·„ì˜ í•˜ë£¨(ê³¨4)
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 13549 ìˆ¨ë°”ê¼­ì§ˆ3(ê³¨5)
   ###### 7. ê¶Œë¯¼
    - ì—†ìŒ
    
### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1423 ë§ì´ ë˜ê³ í”ˆ ì›ìˆ­ì´
> 1. `ë™ì  ê³„íšë²•`ì„ ì´ìš©í•˜ì—¬ ìµœëŒ€í•œ í˜ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ê¸°
> 2. dp : í•´ë‹¹ í›ˆë ¨ì¼ìì— í•´ë‹¹ë˜ëŠ” í˜ì˜ ë³€ë™ë¶„ê°’
> 3. í˜„ì¬ ìºë¦­í„°ë³„ í˜ì˜ ê°’ + í˜ì˜ ë³€ë™ë¶„ => ì´ í˜ì˜ ê°’ ë„ì¶œ
> 4. ì í™”ì‹ 
>   - dp[k + j - i] = ê¸°ì¡´ jì¼ì— ë ˆë²¨ ë³€ë™ë¶„ì´ ì €ì¥ëœ dpê°’. ì¦‰ ë ˆë²¨ë³€ë™ë¶„ê³¼ í›ˆë ¨ì¼ìˆ˜ì˜ í•©ì´ ê°™ì„ ë•Œ, ê°€ì¥ í°ê°’ì„ ì €ì¥í•˜ê¸° ìœ„í•¨
>   - dp[j] + q[k] - q[i] = ê¸°ì¡´ jì¼ì— í•´ë‹¹ë˜ëŠ” ê°’ì— í˜„ì¬ì˜ í˜ì˜ ë³€ë™ë¶„ 

```python
import sys
sys.stdin = open('input.txt')
input = sys.stdin.readline

n = int(input())
p =list(map(int,input().split()))
q =list(map(int,input().split()))
d = int(input())

dp = [0] * 101

now = 0
for i in range(n):
    now += p[i] * q[i]
    p[i] = min(d,p[i])

for i in range(n):
    while p[i] > 0 :
        p[i]-=1
        for j in range(d,-1,-1):
            for k in range(i+1,n):
                if k + j- i <= d:
                    dp[k + j - i] = max(dp[k + j - i], dp[j] + q[k] - q[i])
print(dp[d] + r)


```
#### ğŸ§° ë°±ì¤€ 3190 ë±€
> 1. ì‚¬ê³¼ëŠ” 2ë¡œ ë‚˜ë¨¸ì§€ëŠ” 0ìœ¼ë¡œ, ì´ë™í•œ ê³³ì´ë©´ 1ë¡œ ì €ì¥í•œë‹¤.
> 2. ì£¼ì–´ì§„ ë°©í–¥ì„ í†µí•´ ê²Œì„ì„ ì§„í–‰í•œë‹¤.
>   - ì´ë™ì¹¸ì— ì‚¬ê³¼ê°€ ìˆë‹¤ë©´, ì‚¬ê³¼ëŠ” ì—†ì–´ì§€ê³ , ê¼¬ë¦¬ëŠ” ì›€ì§ì´ì§€ ì•ŠëŠ”ë‹¤.
>   - ì´ë™ì¹¸ì— ì‚¬ê³¼ê°€ ì—†ë‹¤ë©´, ëª¸ê¸¸ì´ë¥¼ ì¤„ì—¬ì„œ ê¼¬ë¦¬ê°€ ìœ„ì¹˜í•œ ì¹¸ì„ ë¹„ì›Œì¤€ë‹¤. ëª¸ê¸¸ì´ëŠ” ë³€ì¹˜ ì•ŠëŠ”ë‹¤. 

```python
from collections import deque

n = int(input())
k = int(input())

graph = [[0] * n for _ in range(n)]
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

for i in range(k):
    a, b = map(int, input().split())
    graph[a - 1][b - 1] = 2

l = int(input())
dirDict = dict()
queue = deque()
queue.append((0, 0))

for i in range(l):
    x, c = input().split()
    dirDict[int(x)] = c

x, y = 0, 0
graph[x][y] = 1
cnt = 0
direction = 0

def turn(alpha):
    global direction
    if alpha == 'L':
        direction = (direction - 1) % 4
    else:
        direction = (direction + 1) % 4


while True:
    cnt += 1
    x += dx[direction]
    y += dy[direction]

    if x < 0 or x >= n or y < 0 or y >= n:
        break

    if graph[x][y] == 2:
        graph[x][y] = 1
        queue.append((x, y))
        if cnt in dirDict:
            turn(dirDict[cnt])

    elif graph[x][y] == 0:
        graph[x][y] = 1
        queue.append((x, y))
        tx, ty = queue.popleft()
        graph[tx][ty] = 0
        if cnt in dirDict:
            turn(dirDict[cnt])

    else:
        break

print(cnt)

```

#### âš½ ë°±ì¤€ 14938 ì„œê°•ê·¸ë¼ìš´ë“œ
> 1. `ë‹¤ìµìŠ¤íŠ¸ë¼` ë¥¼ í†µí•´ ê° ì¶œë°œì§€ì ë¶€í„° ë„ì°©ì§€ì ë“¤ê¹Œì§€ ìµœì†Œ ë¹„ìš©ì„ ì €ì¥í•œë‹¤.
> 2. íƒìƒ‰ë²”ìœ„ ì´ë‚´ì¸ ê²½ìš°ì—ë§Œ ì•„ì´í…œì„ íšë“í•œë‹¤.
> 3. ê°€ì¥ í° ê²½ìš°ë¥¼ ì¶œë ¥í•œë‹¤.

```python
import sys
import heapq

def Dijkstra(start):
    dp = [100 for _ in range(n + 1)]
    INF = int(1e9)
    dp[start]=0
    heapq.heappush(heap,(start,0))
    while heap:
        now, wei  = heapq.heappop(heap)
        if dp[now] < wei:
            continue
        for next, cost in graph[now]:
            next_cost = cost + wei
            if next_cost < dp[next]:
                dp[next] = next_cost
                heapq.heappush(heap,(next,next_cost))
    return dp

n, m, r =map(int,sys.stdin.readline().split())
t = dict(enumerate(map(int,sys.stdin.readline().split()),start=1))
heap = []
graph = [[] for _ in range(n+1)]
for i in range(r):
    a,b,l = map(int,sys.stdin.readline().split())
    graph[a].append([b,l])
    graph[b].append([a,l])

max_val = 0
for i in range(1,n+1):
    distances = Dijkstra(i)
    ans = 0
    for j in range(1,n+1):
        if distances[j] <= m:
            ans += t[j]
    if max_val < ans:
        max_val = ans
print(max_val)

```

#### ğŸ–Œ ë°±ì¤€ 16724 í”¼ë¦¬ë¶€ëŠ” ì‚¬ë‚˜ì´
> 1. ì–´ë””ë“  ë†“ì•„ë„ ê°ˆ ìˆ˜ ìˆëŠ” ì„¸ì´í”„í‹°ì¡´ì´ ìˆë‹¤ëŠ” ê±´ ìœ ë‹ˆì˜¨ - íŒŒì¸ë“œì²˜ëŸ¼ ëŒ€í‘œ ë…¸ë“œê°€ ìˆë‹¤ëŠ” ê²ƒê³¼ ê°™ìŒ
> 2. ì´ ê³¼ì •ì„ `dfs`ë¥¼ í†µí•´ ëª‡ ë¬´ë¦¬ê°€ ìˆëŠ”ì§€ íŒŒì•…í•  ê²ƒì„
> 3. ë‹¤ë¥¸ ë¬´ë¦¬ì¼ ë•Œë§ˆë‹¤ ë‹¤ë¥¸ ì¸ë±ìŠ¤ë²ˆí˜¸ë¥¼ ì €ì¥í•˜ì—¬, ëª‡ê°œì˜ ë¬´ë¦¬ê°€ ë„ì¶œë˜ëŠ”ì§€ í™•ì¸

```python
import sys
input =sys.stdin.readline
def dfs(i,j,c):
    global r
    if visit[i][j] != -1:
        if visit[i][j] == c: r+=1
        return
    visit[i][j] = c
    dir = direction.index(Map[i][j])
    dfs(i+dx[dir],j+dy[dir],c)

n,m = map(int,input().split())
Map = [list(input()) for _ in range(n)]
visit = [[-1] * m for _ in range(n)]
direction = ['L','R','U','D'] # (0,-1), (0,1), (-1,0), (1,0)
dx,dy = [0,0,-1,1],[-1,1,0,0]

r,c = 0,0
for i in range(n):
    for j in range(m):
        dfs(i,j,c)
        c+=1
print(r)
``` 

#### ğŸ™ ë°±ì¤€ 17144 ë¯¸ì„¸ë¨¼ì§€ ì•ˆë…•
> 1. ì²­ì •ê¸°ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ì„œ vacì— ì €ì¥
> 2. í™•ì‚° í•¨ìˆ˜ë¥¼ ë§Œë“¤ê³ , ê³µê¸°ì²­ì •ê¸°ê°€ ì•„ë‹ˆë©´ ì‚¬ë°©ìœ¼ë¡œ í™•ì‚°
> 3. ì—…ê³¼ ë‹¤ìš´í•¨ìˆ˜ë¥¼ í†µí•´ ê° ë¯¸ì„¸ë¨¼ì§€ë¥¼ ì´ë™ì‹œí‚¨ë‹¤. ë§Œì•½ ëª¨ì„œë¦¬ì— ë‹¿ìœ¼ë©´ ë°©í–¥ì„ ì „í™˜í•˜ê³ , ì²­ì •ê¸°ì— ë„ë‹¬í•˜ë©´ ëë‚œë‹¤.

```python
import sys
sys.stdin = open('input.txt')
r, c, t = map(int, input().split())
maps = [list(map(int, input().split())) for _ in range(r)]
input =sys.stdin.readline
vac = []
for i in range(r):
    if maps[i][0] == -1:
        vac.append(i)       # ì²­ì •ê¸°ì˜ ìœ„ì¹˜ë¥¼ ì°¾ìŒ


def spread(maps, sp_maps):      # ë¨¼ì§€ ë¶„ì‚°
    for i in range(r):
        for j in range(c):
            if maps[i][j] != -1 and maps[i][j] > 0:
                sp_dust = maps[i][j] // 5
                for dy, dx in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                    ny, nx = i + dy, j + dx
                    if 0 <= ny < r and 0 <= nx < c and maps[ny][nx] != -1:
                        sp_maps[ny][nx] += sp_dust
                        maps[i][j] -= sp_dust
                sp_maps[i][j] += maps[i][j]

    return sp_maps      # ìƒˆë¡œìš´ ë§µì— ë„£ìŒ


def up():       # ìœ„ìª½ ë°”ëŒ
    dy, dx = [0, -1, 0, 1], [1, 0, -1, 0]
    dir = 0
    before = 0      # ì´ì „ ê°’ì„ ì €ì¥
    y, x = vac[0], 1        # ë°”ë¡œ ì˜¤ë¥¸ìª½ë¶€í„° ì‹œì‘
    while True:
        ny, nx = y + dy[dir], x + dx[dir]       # ì›€ì§ì„
        if y == vac[0] and x == 0:
            maps[y][x] = 0      # ë§Œì•½ ì²­ì •ê¸°ì— ë„ë‹¬í•˜ë©´ 0ìœ¼ë¡œ ë§Œë“¤ê³  ëëƒ„
            break
        if not (0 <= ny < r and 0 <= nx < c):       # ëª¨ì„œë¦¬ì— ë„ë‹¬í•˜ë©´ ë°©í–¥ì„ ì „í™˜í•¨
            dir += 1
            continue
        maps[y][x], before = before, maps[y][x]     # í˜„ì¬ ê°’ì„ ì €ì¥í•˜ê³ , ì´ì „ ê°’ì„ í˜„ì¬ ìœ„ì¹˜ì— ë„£ìŒ
        y, x = ny, nx


def down():     # ì•„ë˜ìª½ ë°”ëŒ
    dy, dx = [0, 1, 0, -1], [1, 0, -1, 0]
    dir = 0
    before = 0
    y, x = vac[1], 1
    while True:
        ny, nx = y + dy[dir], x + dx[dir]
        if y == vac[1] and x == 0:
            maps[y][x] = 0
            break
        if not(0 <= ny < r and 0 <= nx < c):
            dir += 1
            continue
        maps[y][x], before = before, maps[y][x]
        y, x = ny, nx

def count(maps):
    sum = 0
    for i in range(r):
        for j in range(c):
            sum += maps[i][j]
    return sum

for _ in range(t):
    maps = spread(maps, [[0] * c for _ in range(r)])
    up()
    down()
print(count(maps))

```

#### ğŸ‘” í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 1829 ì¹´ì¹´ì˜¤í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶
> 1. `search` í•¨ìˆ˜ : ê°™ì€ ì»¬ëŸ¬ì¸ ê²½ìš°ì—ë§Œ ê³„ì†í•´ì„œ íƒìƒ‰í•˜ëŠ” `bfs`í•¨ìˆ˜
> 2. ë°©ë¬¸í•˜ì§€ ì•Šê±°ë‚˜, 0ì´ ì•„ë‹Œê²¨ìš°ë§Œ íƒìƒ‰í•œë‹¤.

```java
import java.util.*;

class Solution {
    static boolean[][] visit;
    static int[][] map;
    static List<Integer> list;
    static int N, M;
    public int[] solution(int m, int n, int[][] picture) {
        N = n;
        M = m;
        map = picture;
        list = new ArrayList();
        visit = new boolean[m][n];

        for(int i = 0 ; i < m; ++i){
            for(int j = 0 ; j < n; ++j){
                if(!visit[i][j] && map[i][j] != 0){
                    search(i,j);
                }
            }
        }

        int[] answer = new int[2];
        answer[0] = list.size();
        answer[1] = list.stream().max(Integer::compare).get();

        return answer;
    }

    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public void search(int startX, int startY){
        int count = 1;
        visit[startX][startY] = true;
        Queue<int[]> q = new ArrayDeque();
        q.add(new int[] {startX, startY});
        while(!q.isEmpty()){
            int[] cur = q.poll();
            for(int d = 0; d < 4; ++d){
                int nextX = cur[0] + dx[d];
                int nextY = cur[1] + dy[d];
                if(0 <= nextX && nextX < M && 0 <= nextY && nextY < N){
                    if(!visit[nextX][nextY] && map[nextX][nextY] == map[startX][startY]){
                        visit[nextX][nextY] = true;
                        q.add(new int[] {nextX, nextY});
                        count++;
                    }
                }
            }
        }
        list.add(count);
    }
}
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 250136 ì„ìœ ì‹œì¶”
> 1. ê° ì˜ì—­ë“¤ì„ ê°™ì€ ë¬´ë¦¬ë“¤ë¼ë¦¬ ê°™ì€ ìˆ«ìë¡œ ì €ì¥í•œë‹¤.
> 2. ê° ì˜ì—­ì˜ í¬ê¸°ë¥¼ ë”•ì…”ë„ˆë¦¬ì— í•´ë‹¹ í‚¤ì— ì €ì¥í•œë‹¤.
> 3. ì„ìœ  ì‹œì¶”ë¥¼ ìœ„í•´ ê° ì—´ì—ì„œ ì‹œì¶”ê´€ì„ ê¼½ëŠ”ë‹¤.
> 4. ê° í–‰ì— í•´ë‹¹ ë²ˆí˜¸ê°€ ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ ê·¸ ì˜ì—­ì„ ë”í•´ì£¼ë©°, ìµœëŒ“ê°’ì„ ê°±ì‹ í•œë‹¤.

```py
from collections import deque

def solution(land):
    n,m = len(land), len(land[0])
    locations = dict({0:0})
    dr = [(1,0),(0,1),(-1,0),(0,-1)]
    visited = [[False] * m for _ in range(n)]
    idx = 1

    def bfs(i,j,idx):
        cnt = 1
        queue = deque([[i,j]])
        land[i][j]=idx
        visited[i][j]=True
        while queue:
            x,y = queue.popleft()
            for j in range(4):
                nx = x + dr[j][0]
                ny = y + dr[j][1]
                if 0<= nx < n and 0<= ny < m and not visited[nx][ny] and land[nx][ny]==1:
                    visited[nx][ny] = True
                    land[nx][ny]=idx
                    queue.append((nx,ny))
                    cnt+=1
        return cnt

    for i in range(n):
        for j in range(m):
            if land[i][j]==1 and not visited[i][j]:
                locations[idx] = bfs(i,j,idx)
                idx+=1
    result = 0
    for i in range(m):
        temp =set()
        for j in range(n):
            temp.add(land[j][i])
        result = max(result,sum(map(lambda x : locations[x], temp)))

    return result



```
