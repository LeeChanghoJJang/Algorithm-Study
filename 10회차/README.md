## Algorithm Study 10íšŒì°¨ íšŒì˜ (24.4.6.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 4ì›” 6ì¼ í† ìš”ì¼ ì•„ì¹¨ 9ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 4ì›” 13ì¼ í† ìš”ì¼ ì•„ì¹¨ 9ì‹œ 30ë¶„  
        - ë°©ì‹ : ê¹€í•´ ì»¤í”¼íŒ€ë²„ 

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• :ã€ìœ í˜•ã€ ë³„ë¡œ 'ê°ì' 'ìƒ', 'í•˜' ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 2ë¬¸ì œ, ì´ 10ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ : ìµœëŒ€ ë°±ì¤€ ê³¨ë“œ ì´í•˜ 
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ì´ë²ˆ ì£¼ì˜ ìƒˆë¡œìš´ ë¬¸ì œ : íŠ¸ë¦¬DP
      - ë¬¸ì œ ì„ ì •ìê°€ í‘¼ ë°©ì‹ ë¸Œë¦¬í•‘
      - í‘¼ ë°©ì‹ ì´ì™¸ì—ë„ ë‹¤ì–‘í•œ ë°©ë²• ì œì‹œ
      - ë¬¸ì œ ì ‘ê·¼ ë°©ì‹ ìš°ì„ ìˆœìœ„ ë“± ì´ì²´ì  ì •ë¦¬

### ğŸ¤¢ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 2665 ë¯¸ë¡œë§Œë“¤ê¸°(ê³¨ë“œ 4)
    - ë°±ì¤€ 2075 Në²ˆì§¸ í°ìˆ˜(ì‹¤ë²„ 2)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 15681 íŠ¸ë¦¬ì™€ ì¿¼ë¦¬(ê³¨ë“œ 5)
    - ë°±ì¤€ 1654 ëœì„  ìë¥´ê¸°(ì‹¤ë²„ 2)
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 1700 ë©€í‹°íƒ­ ìŠ¤ì¼€ì¤„ë§(ê³¨ë“œ 1)
    - ë°±ì¤€ 2667 ë‹¨ì§€ë²ˆí˜¸ ë¶™ì´ê¸°(ì‹¤ë²„ 1) 
   ###### 4. ë™í˜„
    - ë°±ì¤€ 16974 ë ˆë²¨ í–…ë²„ê±°(ê³¨ë“œ 5)
    - ë°±ì¤€ 1629 ê³±ì…ˆ(ì‹¤ë²„ 1)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 21609 ìƒì–´ ì¤‘í•™êµ(ê³¨ë“œ 2)
    - ë°±ì¤€ 17086 ì•„ê¸° ìƒì–´ 2(ì‹¤ë²„ 2)
  
### ğŸ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 14567 ì„ ìˆ˜ê³¼ëª©(ê³¨ë“œ 5)
    - ë°±ì¤€ 15565 ê·€ì—¬ìš´ ë¼ì´ì–¸(ì‹¤ë²„ 2)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 1450 ëƒ…ìƒ‰ë¬¸ì œ(ê³¨ë“œ 1)
    - ë°±ì¤€ 7576 í† ë§ˆí† (ê³¨ë“œ 5)
   ###### 3. ê²½íƒœ
    - swea 2477 ì°¨ëŸ‰ ì •ë¹„ì†Œ(Aí˜• ëŒ€ë¹„)
    - ë°±ì¤€ 9465 ìŠ¤í‹°ì»¤(ì‹¤ë²„ 1)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 16562 ì¹œêµ¬ë¹„(ê³¨ë“œ 4)
    - ë°±ì¤€ 13335 íŠ¸ëŸ­(ì‹¤ë²„ 1)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 1326 ì†ŒíŠ¸ê²Œì„(ê³¨ë“œ 4)
    - ë°±ì¤€ 20529 ê°€ì¥ ê°€ê¹Œìš´ ì„¸ ì‚¬ëŒì˜ ì‹¬ë¦¬ì  ê±°ë¦¬(ì‹¤ë²„ 1)

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1629 ê³±ì…ˆ
> ë¶„í• ì •ë³µì„ ì´ìš©í•œ ê±°ë“­ì œê³± í™œìš©.(ì¬ê·€í•¨ìˆ˜)
> 1. a : ë°‘, b: ê³±í•˜ëŠ” íšŸìˆ˜, c : ê²°ê³¼ê°’ì„ ë‚˜ëˆŒ ìˆ˜ 
> 2. bê°€ í™€ìˆ˜ì´ë©´ b//2ì—ë‹¤ê°€, í•œë²ˆ ë” ê³±í•œ a%cë¥¼ ê³±í•œ í•¨ìˆ˜ê°’ì„ ë°˜í™˜í•œë‹¤.
> 3. bê°€ ì§ìˆ˜ì´ë©´ b//2ë¥¼ ë„£ì€ í•¨ìˆ˜ê°’ì„ ë°˜í™˜í•œë‹¤.
> 3. bê°€ 1ì´ë©´ a%cë¥¼ ë°˜í™˜í•œë‹¤.

```python
def div_conq(a,b,c):
    if b == 1 :
        return a % c
    
    if b % 2 == 1:
        return div_conq(a,b//2,c)**2 * a % c
    
    else :
        return div_conq(a,b//2,c)**2 % c
#### ì¬ê·€í•¨ìˆ˜ë¥¼ í†µí•´ 10 ** 11 % 12ë¥¼
    # (((10^2)*10)^2*10)% 12 ë¡œ ë§Œë“¬

A,B,C = map(int,input().split())

print(div_conq(A,B,C))
```

> ë‘ë²ˆì§¸ : ë™ì¼í•œ ë¡œì§ì„ ë°˜ë³µë¬¸ì„ í†µí•´ êµ¬í˜„
```python
# ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ ì„¸ ê°œì˜ ì •ìˆ˜ë¥¼ A, B, Cì— í• ë‹¹í•©ë‹ˆë‹¤.
A, B, C = map(int, input().split())

# ëª¨ë“ˆëŸ¬ ì§€ìˆ˜ ì—°ì‚°ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
def power_mod(A, B, C):
    # ê²°ê³¼ë¥¼ ì €ì¥í•  ë³€ìˆ˜ë¥¼ 1ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    result = 1
    # baseì—ëŠ” Aë¥¼ Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.
    base = A % C

    # Bê°€ 0ë³´ë‹¤ í´ ë•Œê¹Œì§€ ë°˜ë³µí•©ë‹ˆë‹¤.
    while B > 0:
        # Bê°€ í™€ìˆ˜ì¼ ë•Œ, ê²°ê³¼ì— baseë¥¼ ê³±í•˜ê³  Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•˜ì—¬ ê²°ê³¼ ë³€ìˆ˜ì— í• ë‹¹í•©ë‹ˆë‹¤.
        if B % 2 == 1:
            result = (result * base) % C
        # baseë¥¼ ì œê³±í•˜ê³  Cë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ base ë³€ìˆ˜ì— í• ë‹¹í•©ë‹ˆë‹¤.
        base = (base * base) % C
        # Bë¥¼ ì ˆë°˜ìœ¼ë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
        B //= 2

    # ìµœì¢…ì ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    return result

# í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê³  ê²°ê³¼ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
print(power_mod(A, B, C))

```

#### ğŸ§° ë°±ì¤€ 1654 ëœì„  ìë¥´ê¸° 
> `ë§¤ê°œë³€ìˆ˜ íƒìƒ‰` ë¡œì§ì„ ì´ìš©í•œ ë¬¸ì œ í’€ì´ 
> 1. ì–´ë–¤ ì‹œì ê¹Œì§€ëŠ” ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ë§Œ, ê·¸ ì´í›„ì—ëŠ” ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ì„œ ìµœëŒ€ê°’ ì°¾ê¸°
> 2. ê·¸ ì™¸ì—ëŠ” ì´ì§„íƒìƒ‰ê³¼ ë™ì¼
> 3. ì•„ë˜ì˜ ê²½ìš°, ìµœëŒ€ì˜ ëœì„ ê¸¸ì´(ìµœëŒ€ê°’)ê³¼ ì¡°ê±´(ëœì„  ê°¯ìˆ˜)ì„ ì¶©ì¡±í•˜ëŠ” ì§€ í™•ì¸ í•„ìš” 
```python
K, N = map(int, input().split())
cables = [int(input()) for _ in range(K)]
start, end = 1, max(cables)

while start <= end:
    mid = (start + end) // 2
    cnt = sum(cable // mid for cable in cables)

    if cnt >= N:
        start = mid + 1
    else:
        end = mid - 1

print(end)
```

#### âš½ ë°±ì¤€ 1700 ë©€í‹°íƒ­ ìŠ¤ì¼€ì¥´ë§
> `ê·¸ë¦¬ë””`ë¥¼ ì´ìš©í•œ ë°˜ë³µë¬¸(`ì¹´ìš´íŠ¸í–‰ë ¬` ì´ìš©)
1. ê¸°ê¸°ê°€ ë©€í‹°íƒ­ì— ê½‚í˜€ ìˆë‹¤ë©´ ë„˜ì–´ê°„ë‹¤.(ì²«ë²ˆì¨°) 
2. ê·¸ ì™¸, ë©€í‹°íƒ­ì— ê³µê°„ì´ ìˆìœ¼ë©´ ê½‚ëŠ”ë‹¤.(ë‘ë²ˆì§¸)
3. ê½‚í˜€ ìˆëŠ” ì½”ë“œ ì¤‘, í–¥í›„ ë‹¤ê°€ì˜¤ëŠ” ë¯¸ë˜ì— ê°€ì¥ ë¹¨ë¦¬ ì“°ëŠ” ê¸°ê¸°ì˜ ìš°ì„ ìˆœìœ„ë¥¼ `use` ë°°ì—´ì— ì €ì¥í•œë‹¤.(ê° ì½”ë“œì˜ ì¸ë±ìŠ¤)
4. ê²°ê³¼ì ìœ¼ë¡œ ëº„ ì½”ë“œë¥¼ ì •í•˜ëŠ”ë°, ë©€í‹°íƒ­ì— ê½‚í˜€ìˆëŠ” ê¸°ê¸°ë“¤ì„ í•˜ë‚˜ì”© ì¡°íšŒí•˜ê³  ì•„ë˜ì™€ ê°™ì´ ì²˜ë¦¬í•œë‹¤.
    - ì‚¬ìš©í• ì¼ ì—†ìœ¼ë©´ ë½‘ëŠ”ë‹¤.
    - ê° ê¸°ê¸°ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ë¹„êµí•˜ì—¬ ë” ë’¤ì— ìˆìœ¼ë©´ ë½‘ëŠ”ë‹¤. 
```python
N, K = map(int, input().split())
apps = list(map(int, input().split()))
tab, cnt = set(), 0

for i, app in enumerate(apps):
    # ë©€í‹°íƒ­ì— ìˆìœ¼ë©´ íŒ¨ìŠ¤
    if app in tab: continue

    # ë©€í‹°íƒ­ì— ê³µê°„ì´ ìˆìœ¼ë©´ ê½‚ìŒ
    if len(tab) < N: tab.add(app)
    else:
        # ê½‚í˜€ìˆëŠ” ì½”ë“œ ì¤‘ ì•ìœ¼ë¡œ ì–¸ì œ ë‹¤ì‹œ ì‚¬ìš©í•  ì§€ ì²´í¬
        use = [0] * 101
        for j, left_app in enumerate(apps[i:]):
            # not use ì“°ëŠ” ì´ìœ ëŠ” ìˆœì°¨ì ìœ¼ë¡œ ê°€ì¥ ë¹ ë¥¸ ìš°ì„ ìˆœìœ„ ì €ì¥ìœ„í•¨
            if not use[left_app] and left_app in tab:
                use[left_app] = j

        pop_app = 0
        for now_app in tab:
            # ì•ìœ¼ë¡œ ì‚¬ìš©í•  ì¼ì´ ì—†ìœ¼ë©´ ë½‘ìŒ
            if not use[now_app]: pop_app = now_app; break
            # ì œì¼ ë§ˆì§€ë§‰ì— ì‚¬ìš©í•  ì½”ë“œ ë½‘ìŒ
            if use[now_app] > use[pop_app]: pop_app = now_app

        tab.remove(pop_app)
        tab.add(app)
        cnt += 1

print(cnt)

```

#### ğŸ–Œ ë°±ì¤€ 2075 Në²ˆì§¸ í°ìˆ˜ 
> `ìš°ì„ ìˆœìœ„ í`ë¥¼ í™œìš©í•˜ì—¬ Në²ˆì§¸ í°ìˆ˜ ë„ì¶œ
> 1. ê·œì¹™ì— ë”°ë¼ ê°™ì€ ì—´ì— ìˆëŠ” ê°’ë“¤ì€ ì´ì „ í–‰ì˜ ê°’ë³´ë‹¤ ë¬´ì¡°ê±´ ë†’ìŒ
> 2. í–‰ì˜ ê°’ì„ ìˆœì°¨ì ìœ¼ë¡œ ë°›ì•„, `heapify`ë¥¼ ì´ìš©í•˜ì—¬ ìµœì†Œí™ìœ¼ë¡œ ë³€í™˜
> 3. Nì˜ ê¸¸ì´ê°€ ë„˜ì„ ê²½ìš°, ìµœì†Œê°’ì„ ë°˜í™˜ 
```python
from heapq import heappop, heapify

N = int(input())
Q = []

for _ in range(N):
    Q += list(map(int, input().split()))
    heapify(Q)
    while len(Q) > N: heappop(Q)

print(Q[0])
``` 

#### ğŸ™ ë°±ì¤€ 2665 ë¯¸ë¡œë§Œë“¤ê¸°
> `ë‹¤ìµìŠ¤íŠ¸ë¼`ë¥¼ ì´ìš©í•œ ë¬¸ì œí’€ì´ 
> 1. ë¹„ìš©ì„ `dist` ë°°ì—´ì— ì €ì¥.(ì´ˆê¸°ê°’ 2*n ì„¤ì •)
> 2. heapì„ ì •ì˜í•œë‹¤.(ê° ìš”ì†ŒëŠ” ë¹„ìš©,x,yìœ¼ë¡œ ì´ë¤„ì§„ë‹¤.)
> 3. heappopì„ í†µí•´ ìµœì†Œê°’ì„ ë§¤ë²ˆ ì¶•ì¶œí•˜ì—¬, `dist`ì— ì €ì¥ëœ ë¹„ìš©ê³¼ ë¹„êµí•œë‹¤. 
> 4. ì¸ì ‘í•œ ë…¸ë“œë¥¼ ìˆœíšŒí•˜ì—¬ ì‹ ê·œë¹„ìš©ì„ ì¼ë‹¨ ê³„ì‚°í•œë‹¤.
> 5. ì´ì›ƒë…¸ë“œì˜ ê¸°ì¡´ ë¹„ìš©ê³¼ ì‹ ê·œ ë¹„ìš©ì„ ë¹„êµí•˜ì—¬ ì‘ì€ ë¹„ìš©ì„ ì €ì¥í•œë‹¤. 

```python
n = int(input())
go = ((0, 1), (1, 0), (0, -1), (-1, 0))
arr = [list(map(int, input())) for _ in range(n)]
dist = [[2*n] * n for _ in range(n)]; dist[0][0] = 0

Q = [[0, 0, 0]]
while Q:
    # ì´ë™ ë¹„ìš©ì´ ê°€ì¥ ì ì€ ì´ì›ƒ ë…¸ë“œë¶€í„° ë°©ë¬¸
    now_cost, i, j = heappop(Q)

    # í˜„ì¬ ë…¸ë“œì˜ ê¸°ì¡´ ë¹„ìš©ê³¼ ì‹ ê·œ ë¹„ìš© ë¹„êµ
    if dist[i][j] < now_cost:
        continue

    # ì´ì›ƒ ë…¸ë“œ ìˆœíšŒ
    for di, dj in go:
        ni, nj = i + di, j + dj
        if 0 <= ni < n and 0 <= nj < n:
            # ì´ì›ƒ ë…¸ë“œì˜ ì‹ ê·œ ë¹„ìš© ê³„ì‚°
            next_cost = now_cost + (1 - arr[ni][nj])

            # ì´ì›ƒ ë…¸ë“œì˜ ê¸°ì¡´ ë¹„ìš©ê³¼ ì‹ ê·œ ë¹„ìš© ë¹„êµ
            if dist[ni][nj] > next_cost:
                dist[ni][nj] = next_cost
                heappush(Q, [next_cost, ni, nj])

print(dist[-1][-1])
```

#### ğŸ‘” ë°±ì¤€ 2667 ë‹¨ì§€ ë²ˆí˜¸ ë¶™ì´ê¸°
> ì²«ë²ˆì§¸ ë°©ë²• : `DFS` í™œìš©
> 1. 1ì¸ ê²½ìš°, ì‹œì‘ì ì„ 0ìœ¼ë¡œ í•˜ê³ , ì¸ì ‘ë…¸ë“œë¥¼ ì „ë¶€ ìˆœíšŒí•˜ëŠ” `DFS`ë¥¼ í†µí•´ ë¸”ë¡ì˜ í¬ê¸°ë¥¼ ë°˜í™˜í•œë‹¤.
> 2. í•´ë‹¹ ê°’ì„ ë¦¬ìŠ¤íŠ¸ì— ë„£ê³ , ìˆœì°¨ì ìœ¼ë¡œ ê°’ì„ ë°˜í™˜í•œë‹¤. 
```python
def DFS(arr, i, j, cnt):
    S = [[i, j]]
    while S:
        i, j = S.pop()
        for di, dj in go:
            ni, nj = i + di, j + dj
            if 0 <= ni < n and 0 <= nj < n and arr[ni][nj]:
                arr[ni][nj] = 0; cnt += 1; S.append([ni, nj])
    return cnt

n, ans = int(input()), []
go = ((0, 1), (1, 0), (0, -1), (-1, 0))
arr = [list(map(int, input())) for _ in range(n)]

for i in range(n):
    for j in range(n):
        if arr[i][j]:
            arr[i][j] = 0
            ans.append(DFS(arr, i, j, 1))

print(len(ans))
for i in sorted(ans): print(i)

```
> ë‘ë²ˆì§¸ ë°©ë²• : `BFS` í™œìš©
```py
from collections import deque

# ìƒí•˜ì¢Œìš° ì´ë™ì„ ìœ„í•œ ë°©í–¥ ë²¡í„°
dr = [(0, 1), (1, 0), (0, -1), (-1, 0)]

def BFS(x, y):
    queue = deque([[x, y]])  # ì‹œì‘ì ì„ íì— ì¶”ê°€í•©ë‹ˆë‹¤.
    cnt = 1  # í˜„ì¬ ì˜ì—­ì˜ í¬ê¸°ë¥¼ ì €ì¥í•  ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    while queue:
        x, y = queue.popleft()
        for i in range(4):
            nx = x + dr[i][0]  # ë‹¤ìŒ í–‰ ì¢Œí‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            ny = y + dr[i][1]  # ë‹¤ìŒ ì—´ ì¢Œí‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            if 0 <= nx < N and 0 <= ny < N and arr[nx][ny] == '1':
                arr[nx][ny] = '0'  # ë°©ë¬¸í•œ ì˜ì—­ì„ í‘œì‹œí•©ë‹ˆë‹¤.
                cnt += 1  # ì˜ì—­ì˜ í¬ê¸°ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.
                queue.append([nx, ny])  # ë‹¤ìŒ ìœ„ì¹˜ë¥¼ íì— ì¶”ê°€í•©ë‹ˆë‹¤.
    return cnt  # í˜„ì¬ ì˜ì—­ì˜ í¬ê¸°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

N = int(input())  # ê·¸ë¦¬ë“œì˜ í¬ê¸° Nì„ ì…ë ¥ë°›ìŠµë‹ˆë‹¤.
arr = [list(input()) for _ in range(N)]  # ê·¸ë¦¬ë“œ ì •ë³´ë¥¼ ì…ë ¥ë°›ìŠµë‹ˆë‹¤.

result = []  # ê° ì˜ì—­ì˜ í¬ê¸°ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
for i in range(N):
    for j in range(N):
        if arr[i][j] == '1':  # ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ 1ì´ë¼ë©´,
            arr[i][j] = '0'  # í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆë‹¤ê³  í‘œì‹œí•©ë‹ˆë‹¤.
            result.append(BFS(i, j))  # BFSë¥¼ í†µí•´ í˜„ì¬ ì˜ì—­ì˜ í¬ê¸°ë¥¼ êµ¬í•˜ê³  ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤.

print(len(result))  # ì˜ì—­ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
for area in sorted(result):  # ì˜ì—­ì˜ í¬ê¸°ë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
    print(area)
``` 
---
#### ğŸ“€ ë°±ì¤€ 15681 íŠ¸ë¦¬ì™€ ì¿¼ë¦¬ 
> íŠ¸ë¦¬ì˜ ë…¸ë“œë³„ë¡œ ì„œë¸ŒíŠ¸ë¦¬ì˜ ê°¯ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´ì„ íŠ¸ë¦¬ì˜ DPë¡œ êµ¬í˜„
> 1. íŠ¸ë¦¬ì˜ ì—°ê²°ì •ë³´ë¥¼ ë¨¼ì € `tree`ì— ì €ì¥í•œë‹¤. 
> 2. ë°©ë¬¸ì•ˆí•œ ë…¸ë“œë¥¼ ê³„ì†í•´ì„œ ìˆœíšŒí•˜ë©´ì„œ, ìì‹ë…¸ë“œê°€ ì—†ì„ ë•Œê¹Œì§€ ê°„ë‹¤.
> 3. ì¢…ì  ë…¸ë“œì— ë„ì°©í•˜ë©´ ë¶€ëª¨ë…¸ë“œì˜ ì„œë¸ŒíŠ¸ë¦¬ì— ìì‹ë…¸ë“œì˜ ì„œë¸ŒíŠ¸ë¦¬ê°’ì„ ê³„ì† ë”í•œë‹¤. 

```python
def DFS(now):
    visit[now] = 1
    for next in tree[now]:
        if not visit[next]:
            DFS(next)
            # ìì‹ ì„œë¸Œ íŠ¸ë¦¬ì˜ ì„œë¸Œ íŠ¸ë¦¬ ë…¸ë“œ ê°œìˆ˜ í•©ì‚°
            subtree[now] += subtree[next]

N, R, Q = map(int, input().split())
tree = [[] for _ in range(N+1)]
visit = [0] * (N+1)
subtree = [1] * (N+1)

# íŠ¸ë¦¬ ìƒì„±
for _ in range(N-1):
    U, V = map(int, input().split())
    tree[U].append(V)
    tree[V].append(U)

DFS(R)
[print(subtree[int(input())]) for _ in range(Q)]
```

#### ğŸ§â€â™€ï¸ ë°±ì¤€ 16974 ë ˆë²¨ í–„ë²„ê±°
> `DP`ë¥¼ í™œìš©í•œ ë¬¸ì œí’€ì´ : ì¬ê·€í•¨ìˆ˜
> 1. ì´ ê°¯ìˆ˜(2n+3) = íŒ¨í‹° ê°¯ìˆ˜(n+1) + ë²ˆ ê°¯ìˆ˜(n+2)
> 2. í˜„ì¬ ë‹¨ê³„ì˜ ì´ ê°¯ìˆ˜ = ì´ì „ ë‹¨ê³„ì˜ ì´ ê°¯ìˆ˜ * 2 + 3
> 3. í˜„ì¬ ë‹¨ê³„ì˜ íŒ¨í‹° ê°¯ìˆ˜ = í˜„ì¬ ë‹¨ê³„ì˜ ì´ ê°¯ìˆ˜ // 2
```python
# 16974 ë ˆë²¨ í–„ë²„ê±°
#  Lv |   Thickness   |     patty     |
# -------------------------------------
#  0  |  1            |  1            |
#  1  |  5 = 3 + 2*1  |  3 = 1 + 2*1  |
#  2  | 13 = 3 + 2*5  |  7 = 1 + 2*3  |
#  3  | 29 = 3 + 2*13 | 15 = 1 + 2*7  |
#  4  | 61 = 3 + 2*29 | 31 = 1 + 2*15 |
#  5  |125 = 3 + 2*61 | 63 = 1 + 2*31 |

def search(N, X):
    # L-0 ê¹Œì§€ ë„ë‹¬
    if N == 0:
        return 1

    # 1ì¥ ì„­ì·¨
    if X == 1:
        return 0

    # ì ˆë°˜ ë¯¸ë§Œ ì„­ì·¨
    elif X < burger[N-1] + 2:
        return search(N-1, X-1)

    # ì ˆë°˜ ì„­ì·¨
    elif X == burger[N-1] + 2:
        return patty[N-1] + 1

    # ì „ì²´ ë¯¸ë§Œ ì„­ì·¨
    elif X < burger[N]:
        return patty[N-1] + 1 + search(N-1, X - burger[N-1] - 2)

    # ì „ì²´ ì„­ì·¨
    else:
        return patty[N]

N, X = map(int, input().split())
burger = [1] * 51; patty = [1] * 51

for i in range(1, N + 1):
    burger[i] = 3 + 2 * burger[i - 1]
    patty[i] = 1 + 2 * patty[i - 1]

print(search(N, X))
```
> `DP`ë¥¼ í™œìš©í•œ ë¬¸ì œí’€ì´ : ë°˜ë³µë¬¸ í™œìš©
```py
N, X = map(int, input().split())  

def hamburger(N, X):
    result = 0 
    while N >= 0:
        # Xì˜ ìœ„ì¹˜ê°€ ì „ì²´ í¬ê¸°ì™€ ê°™ì€ ê²½ìš°
        if X == DP[N][0]:
            result += DP[N][1]
            return result
        # Xì˜ ìœ„ì¹˜ê°€ ë”± ì¤‘ê°„ì¸ ê²½ìš°
        elif X == DP[N][0] // 2 + 1: 
            result += DP[N][1] // 2 + 1  
            return result
        # Xì˜ ìœ„ì¹˜ê°€ ì¤‘ê°„ë³´ë‹¤ ë†’ì€ ê²½ìš°
        # ì¤‘ê°„ë§Œí¼ ë¨¹ê³  ë“¤ì–´ê°€ê³ , ì¤‘ê°„ì´ë‚´ ë²”ìœ„ë§Œí¼ íŒ¨í‹°ê°¯ìˆ˜ë¥¼ ì €ì¥í•œë‹¤.
        # ìœ„ì¹˜ë¥¼ ì¬ì¡°ì •í•œë‹¤.(ì¤‘ê°„ìœ„ì¹˜ë¥¼ ì°¨ê°í•œ ë§Œí¼)
        elif X > DP[N][0] // 2 + 1:  
            X -= DP[N - 1][0] + 2 
            result += DP[N][1] // 2 + 1  
        # ë§Œì•½ ì¤‘ê°„ ìœ„ì¹˜ë³´ë‹¤ ì‘ì€ ê²½ìš°ì—ëŠ”, Xë¥¼ 1ì”© ì°¨ê°í•œë‹¤. 
        # ì™œëƒí•˜ë©´ í–„ë²„ê±°ì˜ í¬ê¸°ì—ì„œ ë²ˆ 1ê°œ ë¹¼ì¤˜ì•¼ í•œë‹¤.
        else: 
            X -= 1  
        N -= 1  
    return result  

# DP ë°°ì—´ ì´ˆê¸°í™”
DP = [[1, 1] for _ in range(N + 1)]  
# DP ì €ì¥ì •ë³´ : ì´ ê°¯ìˆ˜, íŒ¨í‹° ê°¯ìˆ˜ ì €ì¥
for i in range(1, N + 1):
    DP[i][0] = 2 * DP[i - 1][0] + 3  
    DP[i][1] = 2 * DP[i - 1][1] + 1  

print(hamburger(N, X)) 
```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 17086 ì•„ê¸° ìƒì–´ 2
> `BFS`ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ì¹˜ë³„ ìµœë‹¨ê±°ë¦¬ë¥¼ ë°˜í™˜í•œë‹¤. 
```python
from collections import deque

# ë°©í–¥ ë²¡í„° ì •ì˜
dx = [0, 0, 1, -1, 1, 1, -1, -1]
dy = [1, -1, 0, 0, 1, -1, 1, -1]

# ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS) í•¨ìˆ˜ ì •ì˜
def BFS(x, y, visited):
    queue = deque([[x, y]])
    visited[x][y] = 1

    # íê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ
    while queue:
        x, y = queue.popleft()

        # 8ë°©í–¥ íƒìƒ‰
        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]

            # ë°°ì—´ ë²”ìœ„ ë‚´ì— ìˆê³ , ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            if 0 <= nx < N and 0 <= ny < M and visited[nx][ny] == 0:
                # ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ ë°©ë¬¸ í‘œì‹œ
                visited[nx][ny] = visited[x][y] + 1
                queue.append([nx, ny])

                # 1ë¡œ í‘œì‹œëœ ì§€ë¢°ë¥¼ ë§Œë‚¬ë‹¤ë©´ ìµœë‹¨ ê±°ë¦¬ ë°˜í™˜
                if arr[nx][ny] == 1:
                    return visited[nx][ny] - 1

# ì…ë ¥ ë°›ê¸°
N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

max_val = 0

# ëª¨ë“  ìœ„ì¹˜ì— ëŒ€í•´ í™•ì¸
for i in range(N):
    for j in range(M):
        # ì§€ë¢°ê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
        if arr[i][j] == 0:
            temp = BFS(i, j, [[0] * M for _ in range(N)])
            max_val = max(max_val, temp)

# ê²°ê³¼ ì¶œë ¥
print(max_val)

```
> `BFS`ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ì¹˜ë³„ ìµœë‹¨ê±°ë¦¬ë¥¼ ë°˜í™˜í•œë‹¤. 
```python
from collections import deque

# ë°©í–¥ ë²¡í„° ì •ì˜
dx = [0, 0, 1, -1, 1, 1, -1, -1]
dy = [1, -1, 0, 0, 1, -1, 1, -1]

# ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS) í•¨ìˆ˜ ì •ì˜
def BFS(x, y, visited):
    queue = deque([[x, y]])
    visited[x][y] = 1

    # íê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ
    while queue:
        x, y = queue.popleft()

        # 8ë°©í–¥ íƒìƒ‰
        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]

            # ë°°ì—´ ë²”ìœ„ ë‚´ì— ìˆê³ , ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            if 0 <= nx < N and 0 <= ny < M and visited[nx][ny] == 0:
                # ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ ë°©ë¬¸ í‘œì‹œ
                visited[nx][ny] = visited[x][y] + 1
                queue.append([nx, ny])

                # 1ë¡œ í‘œì‹œëœ ì§€ë¢°ë¥¼ ë§Œë‚¬ë‹¤ë©´ ìµœë‹¨ ê±°ë¦¬ ë°˜í™˜
                if arr[nx][ny] == 1:
                    return visited[nx][ny] - 1

# ì…ë ¥ ë°›ê¸°
N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

max_val = 0

# ëª¨ë“  ìœ„ì¹˜ì— ëŒ€í•´ í™•ì¸
for i in range(N):
    for j in range(M):
        # ì§€ë¢°ê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
        if arr[i][j] == 0:
            temp = BFS(i, j, [[0] * M for _ in range(N)])
            max_val = max(max_val, temp)

# ê²°ê³¼ ì¶œë ¥
print(max_val)
```
> `Dijkstra` ì´ìš©
```py
from collections import deque

def BFS(sea, i, j):
    dist = [[0] * M for _ in range(N)]
    Q = deque([[i, j]])
    while Q:
        i, j = Q.popleft()
        for di, dj in go:
            ni, nj = i + di, j + dj
            if 0 <= ni < N and 0 <= nj < M and not dist[ni][nj]:
                dist[ni][nj] = dist[i][j] + 1
                if sea[ni][nj]: return dist[ni][nj]
                Q.append([ni, nj])

go = ((1, 1), (1, 0), (1, -1), (0, 1), (0, -1), (-1, 1), (-1, 0), (-1, -1))
N, M = map(int, input().split())
sea = [list(map(int, input().split())) for _ in range(N)]
ans = 0

for i in range(N):
    for j in range(M):
        if not sea[i][j]:
            ans = max(ans, BFS(sea, i, j))
print(ans)
```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 21609 ìƒì–´ ì¤‘í•™êµ
> `ì‹œë®¬ë ˆì´ì…˜` + `êµ¬í˜„` ë¬¸ì œ
> 1. `DFS`ë¥¼ ì´ìš©í•˜ì—¬ ìµœëŒ€ ë¸”ë¡ í¬ê¸°ë¥¼ ì°¾ëŠ”ë‹¤.
> 2. íƒìƒ‰ê³¼ì •ì—ì„œ ë¬´ì§€ê°œ ë¸”ë¡ê°¯ìˆ˜, ë¸”ë¡í¬ê¸°ì™€ ëª¨ë“  ë¸”ë¡ì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•œë‹¤.
> 3. `gravity` : ì¤‘ë ¥í•¨ìˆ˜
> 4. `turn` :  90ë„ ë°˜ì‹œê³„ë°©í–¥ íšŒì „ í•¨ìˆ˜
> 5. ë¸”ë¡ì„ ì°¾ëŠ” ë¡œì§ì„ ë°˜ë³µí•œë‹¤. (ë¬´ì§€ê°œì™€ ê²€ì€ ë¸”ë¡ ì œì™¸)
> 6. 1 í¬ê¸° ì´ìƒì˜ ë¸”ë¡ê·¸ë£¹ì´ ì—†ìœ¼ë©´ ê°•ì œ ì¢…ë£Œ.
> 7. ê·¸ ì™¸ì˜ ê²½ìš°, ëª¨ë“  ë¸”ë¡ë“¤ì„ ì•„ë˜ ìˆœì„œì— ë”°ë¼ ì •ë ¬í•œë‹¤.
>   - ë¸”ë¡í¬ê¸°, ë¬´ì§€ê°œ ë¸”ë¡ í¬í•¨ê°¯ìˆ˜, í–‰ê³¼ ì—´ìˆœ
>   - ì ìˆ˜ì˜ ì œê³±ì„ ê³„ì† ë”í•´ì¤€ë‹¤. 
```py
def DFS(i, j, C):
    stack = [[i, j]]
    n_cnt, r_cnt = 1, 0
    n_cube, r_cube = [[i, j]], []

    while stack:
        i, j = stack.pop()
        for di, dj in go:
            ni = i + di
            nj = j + dj

            if 0 <= ni < N and 0 <= nj < N and visit[ni][nj] == 0:
                # íŠ¹ì • ìƒ‰ ë¸”ë¡
                if grid[ni][nj] == C:
                    visit[ni][nj] = 1
                    stack.append([ni, nj])
                    n_cube.append([ni, nj])
                    n_cnt += 1

                # ë¬´ì§€ê°œ ë¸”ë¡
                if grid[ni][nj] == 0:
                    visit[ni][nj] = 1
                    stack.append([ni, nj])
                    r_cube.append([ni, nj])
                    n_cnt += 1; r_cnt += 1

    for i, j in r_cube: visit[i][j] = 0

    return n_cnt, r_cnt, n_cube + r_cube

def gravity(arr):
    # ë°‘ì—ì„œ ë¶€í„° íƒìƒ‰
    for i in range(N - 2, -1, -1):
        for j in range(N):
            if 0 <= arr[i][j] <= M:
                temp = arr[i][j]; arr[i][j] = -2; ni = i
                # ë°”ë‹¥ì´ë‚˜ ê²€ì€ ë¸”ë¡ì— ë‹¿ì„ ë•Œê¹Œì§€ ë‚™í•˜
                while ni < N - 1 and arr[ni + 1][j] == -2: ni += 1
                arr[ni][j] = temp

def turn(arr):
    new_arr = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            new_arr[i][j] = arr[j][N - i - 1]
    return new_arr

go = ((1, 0), (0, 1), (0, -1), (-1, 0))
N, M = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(N)]
ans = 0

while True:
    visit = [[0] * N for _ in range(N)]
    groups = []

    # ë¸”ë¡ ê·¸ë£¹ íƒìƒ‰
    for i in range(N):
        for j in range(N):
            if 0 < grid[i][j] and visit[i][j] == 0:
                visit[i][j] = 1
                group = DFS(i, j, grid[i][j])
                if group[0] > 1: groups.append(group)

    # ë¸”ë¡ ê·¸ë£¹ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì¢…ë£Œ
    if not groups: exit(print(ans))
    # ì¡°ê±´ì— ë§ëŠ” ë¸”ë¡ ì°¾ê¸° : ë¸”ë¡ ê°œìˆ˜ - ë¬´ì§€ê°œ ê°œìˆ˜ - í–‰ê³¼ ì—´
    B, R, cubes = sorted(groups, reverse=True)[0]

    # ë¸”ë¡ ì œê±° - ì ìˆ˜ íšë“ - ì¤‘ë ¥ - íšŒì „ - ì¤‘ë ¥
    for i, j in cubes: grid[i][j] = -2
    ans += B**2
    gravity(grid)
    grid = turn(grid)
    gravity(grid)
```
