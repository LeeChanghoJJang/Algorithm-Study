## Algorithm Study 14íšŒì°¨ íšŒì˜ (24.5.5.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 5ì›” 5ì¼ ì¼ìš”ì¼ ì €ë… 7ì‹œ  
        - ë°©ì‹ : ë””ìŠ¤ì½”ë“œ

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 5ì›” 12ì¼ ì¼ìš”ì¼ ì˜¤ì „ 9ì‹œ  
        - ë°©ì‹ : ì†¡ì •ì‚¼ì •ì˜¤í”¼ìŠ¤í…” 2ì¸µ íœ´ê²Œì‹¤

    ë‹¤. ë³€ê²½ì‚¬í•­
        1. íšŒì˜ ì¼ì • ê¸°ë³¸ê°’ì€ ì¼ìš”ì¼ ì˜¤ì „ 9ì‹œ(í˜‘ì˜ í›„ ë³€ë™ë  ìˆ˜ ìˆìŒ)
        2. ìµœì†Œí•œì˜ ê³µë™ëª©í‘œì¸ "ì½”í…Œí•©ê²©"ì„ ê¸°ì›í•˜ê¸° ìœ„í•´ ë¬¸ì œ ìˆ˜ëŠ” ëŠ˜ë¦¬ê³  ë‚œì´ë„ëŠ” ë‚®ì¶”ì–´ ìµœëŒ€í•œ ë‹¤ì–‘í•œ ë¬¸ì œ ì„ ì •
            - ì´ë²ˆ ì£¼ëŠ” ê°ì í•œ ë¬¸ì œë©°, ë³¸ì¸ì´ ì„ ì •í•œ ë¬¸ì œëŠ” ë¼ì´ë¸Œë¡œ ì½”ë”©í•  ê²ƒì´ë‹ˆ, ì‹ ì¤‘íˆ ì„ ì • í•„ìš”
            - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ í™˜ê²½ì—ì„œë„ ë§ì´ ì¹˜ëŠ” ê²ƒì„ ê°ì•ˆí•˜ì—¬ ë°±ì¤€ ì™¸ì— ì‚¬ì´íŠ¸ë„ ì°¸ê³ í•˜ì—¬ ì„ ì • 
        3. ì–´ë ¤ìš´ ë¬¸ì œë¥¼ í•œ ëª…ì”© ì„ ì •.
            - ìˆœì„œ : ì´ë²ˆì£¼ ë°•ë™í˜„ (ì´ìƒí˜„ - ì´ì°½í˜¸ - ì„ê²½íƒœ - ìµœì§€ìš° - ë°•ë™í˜„ - ìœ¤ì˜ˆë¦¬ - ì´ê¶Œë¯¼) -> ì²« ì°¨ë¡€ëŠ” ì˜ˆë¦¬ ê±´ë„ˆë›´ë‹¤.
        4. ì¥ì†Œ ì„ ì • : ìŠ¤í„°ë””ì›ì´ ì¦ëŒ€ë˜ì–´ ì¥ì†Œë¥¼ ì†¡ì‚¼, ê¹€í•´ ì¤‘ í•˜ë‚˜ë¡œ ê²°ì •(1ë²ˆì”© ë¡œí…Œì´ì…˜)
        5. ì–´ë ¤ìš´ ë¬¸ì œ ê¸°ì¤€
            - ë°±ì¤€ : ê³¨ë“œ 3 ì´ìƒ
            - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ : Lv.3 ì´ìƒ
            - SWEA : D5 ë˜ëŠ” Aí˜• ì—­ëŸ‰í…ŒìŠ¤íŠ¸ 
            - ì†Œí”„í‹°ì–´ : Lv.3 ì´ìƒ
        
### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• : ì½”ë”©í…ŒìŠ¤íŠ¸ ê¸°ì¶œ ìœ„ì£¼ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ 
        - ë°±ì¤€ í”Œë˜í‹°ë„˜ ì´í•˜
        - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv.4 ì´í•˜
        - SWEA D6 ì´í•˜    
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ì´ë²ˆ ì£¼ì˜ ì–´ë ¤ìš´ ë¬¸ì œ : ì² ë¡œ
      - ë¬¸ì œ ì„ ì •ìê°€ ë¼ì´ë¸Œ ì½”ë”©í•˜ë©´ì„œ ì†”ë£¨ì…˜ ë¦¬ë·°
      - í‘¼ ë°©ì‹ ì´ì™¸ì—ë„ ë‹¤ì–‘í•œ ë°©ë²• ì œì‹œ

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì‹ ê³  ê²°ê³¼ ë°›ê¸° (2022 KAKAO BLIND RECRUITMENT, Lv.1)
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ê°œì¸ì •ë³´ ìˆ˜ì§‘ ìœ íš¨ê¸°ê°„ (2023 KAKAO BLIND RECRUITMENT, Lv.1)
   ###### 2. ì˜ˆë¦¬
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ê°™ì€ ìˆ«ìëŠ” ì‹«ì–´ (Lv.1)
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì„±ê²© ìœ í˜• ê²€ì‚¬í•˜ê¸°(2022 KAKAO TECH INTERNSHIP, Lv.1)
   ###### 3. ê²½íƒœ
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ë‘ í í•© ê°™ê²Œ ë§Œë“¤ê¸°(2022 KAKAO TECH INTERNSHIP, Lv.2)
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ í‚¤íŒ¨ë“œ ëˆ„ë¥´ê¸°(2020 ì¹´ì¹´ì˜¤ ì¸í„´ì‹­, Lv.1)
   ###### 4. ë™í˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ [1ì°¨] ìºì‹œ (2018 KAKAO BLIND RECRUITMENT, Lv.2)
    - ë°±ì¤€ 12100 2048(Easy)(ê³¨ë“œ 2) - ì‹œë®¬ë ˆì´ì…˜ 
   ###### 5. ìƒí˜„
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ê°€ì¥ ë§ì´ ë°›ì€ ì„ ë¬¼ (2024 KAKAO WINTER INTERNSHIP, Lv.1)
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´ (2021 ì¹´ì¹´ì˜¤ ì±„ìš©ì—°ê³„í˜• ì¸í„´ì‹­, Lv.1)
   ###### 6. ì§€ìš°
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ í¬ë ˆì¸ ì¸í˜•ë½‘ê¸° ê²Œì„(2019 ì¹´ì¹´ì˜¤ ê°œë°œì ê²¨ìš¸ ì¸í„´ì‹­, Lv.1)
    - ë°±ì¤€ 13334 ì² ë¡œ(ê³¨ë“œ 2) - ìš°ì„ ìˆœìœ„ í
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 17471 ê²Œë¦¬ë§¨ë”ë§(ê³¨ë“œ 3) - ì¡°í•©ë¡ , DFS, BFS
    - ë°±ì¤€ 17135 ìºìŠ¬ë””íœìŠ¤(ê³¨ë“œ 3) - ì‹œë®¬ë ˆì´ì…˜, BFS, DFS

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258707 n+1 ì¹´ë“œê²Œì„(2024 KAKAO WINTER INTERNSHIP, Lv.3) 
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 2146 ë‹¤ë¦¬ë§Œë“¤ê¸°(ê³¨ë“œ 3) 
   ###### 3. ê²½íƒœ
   ###### 4. ë™í˜„
   ###### 5. ìƒí˜„
   ###### 6. ì§€ìš°
   ###### 7. ê¶Œë¯¼

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 12100 2048(easy)
> `ë°±íŠ¸ë˜í‚¹` ì„ í™œìš©í•˜ì—¬ `ì‹œë®¬ë ˆì´ì…˜` êµ¬í˜„
> 1. rotate : 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „ì‹œí‚¤ëŠ” í•¨ìˆ˜
> 2. merge : ë¦¬ìŠ¤íŠ¸ë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³ , ë³‘í•©í•˜ëŠ” í•¨ìˆ˜. 0ì´ ì•„ë‹Œ ìˆ«ìë“¤ì— í•œí•´ ê°™ì€ ìˆ«ìê°€ ìˆë‹¤ë©´ í•©ì¹˜ê¸°
> 3. dfsë¥¼ ìˆ˜í–‰í•˜ì—¬ ê¹Šì´ë¥¼ ì¤„ì—¬ 0ë©´ í˜„ì¬ ìµœëŒ€ê°’ ë°˜í™˜

```python
from copy import deepcopy

# 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „ì‹œí‚¤ëŠ” í•¨ìˆ˜
def rotate(list_, size):
    new_list = deepcopy(list_)
    for row in range(size):
        for col in range(size):
            new_list[size - col - 1][row] = list_[row][col]
    return new_list

# ë¦¬ìŠ¤íŠ¸ë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³  ë³‘í•©í•˜ëŠ” í•¨ìˆ˜
def merge(list_):
    # 0ì´ ì•„ë‹Œ ìˆ«ìë§Œ í•„í„°ë§
    temp = [i for i in list_ if i]

    for i in range(1, len(temp)):
        # ì—°ì†ëœ ê°™ì€ ìˆ«ìê°€ ìˆë‹¤ë©´ í•©ì¹˜ê¸°
        if temp[i] == temp[i - 1]:
            temp[i - 1] *= 2
            temp[i] = 0
    # 0ì´ ì•„ë‹Œ ìˆ«ìë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” 0ìœ¼ë¡œ ì±„ì›€
    temp = [i for i in temp if i]
    return temp + [0] * (len(list_) - len(temp))

# ê¹Šì´ ìš°ì„  íƒìƒ‰ìœ¼ë¡œ ìµœëŒ€ ì ìˆ˜ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
def dfs(list_, size, depth):
    # í˜„ì¬ ë³´ë“œì—ì„œ ê°€ì¥ í° ê°’ ì°¾ê¸°
    max_ = max([max(row) for row in list_])
    # ê¹Šì´ê°€ 0ì´ë©´ í˜„ì¬ ìµœëŒ€ ê°’ ë°˜í™˜
    if depth == 5:
        return max_

    # ë„¤ ë°©í–¥ìœ¼ë¡œ ë³´ë“œë¥¼ íšŒì „í•˜ë©´ì„œ ê°ê°ì˜ ê²½ìš° ê³„ì‚°
    for _ in range(4):
        new_list = [merge(row) for row in list_]
        # í˜„ì¬ ë³´ë“œì™€ íšŒì „ í›„ ë³´ë“œê°€ ë‹¤ë¥´ë‹¤ë©´ ê³„ì† íƒìƒ‰
        if new_list != list_:
            max_ = max(max_, dfs(new_list, size, depth + 1))
        # ë³´ë“œë¥¼ ì‹œê³„ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „
        list_ = rotate(list_, size)
    return max_

# ì…ë ¥ ë°›ê¸°
N = int(input())
list_ = [list(map(int, input().split())) for _ in range(N)]

# ê¹Šì´ ìš°ì„  íƒìƒ‰ í˜¸ì¶œí•˜ì—¬ ê²°ê³¼ ì¶œë ¥
print(dfs(list_, N, 0))
```

#### ğŸ§° ë°±ì¤€ 13334 ì² ë¡œ
> `ìš°ì„ ìˆœìœ„ í` ë° `ìŠ¬ë¼ì´ë”© ìœˆë„ìš°` ë°©ì‹ì„ ì´ìš©í•˜ì—¬ ìµœëŒ€ ì¹´ìš´íŠ¸ ì„¸ê¸°
> 1. ê° ì² ë¡œë¥¼ ì¢…ì°©ì ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
> 2. ê±´ë¬¼ì˜ ì™¼ìª½ ëì ì„ ê¸°ì¤€ìœ¼ë¡œ í™ì— ë„£ê³  ë¹¼ê³ ë¥¼ ë°˜ë³µ
```python
# 13334 ì² ë¡œ
import heapq

N = int(input())
bulidings = sorted([sorted(map(int, input().split())) for _ in range(N)], key=lambda x: (x[1], x[0]))
D = int(input())
Q = []; ans = 0

# ëì ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ëœ ê±´ë¬¼ë“¤ ìˆœíšŒ
for building in bulidings:
    # ê±´ë¬¼ì˜ ëì ì„ ê¸°ì¤€ìœ¼ë¡œ ì² ë¡œ ì„¤ì •
    left, right = building
    heapq.heappush(Q, left)

    # ì‹œì‘ì ì´ ì² ë¡œ ë²”ìœ„ ë°–ì— ìˆëŠ” ê²½ìš° ì œê±°
    while Q and Q[0] < right - D:
        heapq.heappop(Q)
    
    # ì‹œì‘ì ì´ ì² ë¡œ ë²”ìœ„ ì•ˆì— ìˆëŠ” ê²½ìš° ì¹´ìš´íŠ¸
    ans = max(ans, len(Q))

print(ans)
```


#### âš½ ë°±ì¤€ 17135 ìºìŠ¬ ë””íœìŠ¤
> `ì‹œë®¬ë ˆì´ì…˜` + `BFS` í™œìš© ë¬¸ì œ
> 1. ëª¨ë“  ì—´ ì¤‘ì— 3ê°œì˜ ì—´ì„ ì„ íƒí•˜ì—¬ ê¶ìˆ˜ë¥¼ ë°°ì¹˜í•œë‹¤(`combinations`)
> 2. vistied : ëª¨ë“  ë°°ì—´ì— ë°©ë¬¸ ìœ„ì¹˜ë¥¼ ë‘”ë‹¤. 
> 3. queueì— í˜„ì¬ ê¶ìˆ˜ìœ„ì¹˜ì™€ ì‚¬ì •ê±°ë¦¬ë¥¼ ë‹´ëŠ”ë‹¤.
> 4. ê¶ìˆ˜ì˜ ì‚¬ì •ê±°ë¦¬ ë‚´ì— ìˆìœ¼ë©´ ì£½ì´ê³  ë‹¤ìŒ í„´ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤. 
> 5. ë‹¨, ë™ì‹œì— ì£½ì´ê³  ë‹¤ìŒí„´ìœ¼ë¡œ ë„˜ì–´ê°€ì•¼ í•œë‹¤. 
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
per_n = sorted(list(map(int, input().split())))
per_m = sorted(list(map(int, input().split())))

# ë§Œì•½ nì´ ë§ìœ¼ë©´ ë‚¨ë…€ë¥¼ ë°”ê¿”ì¤€ë‹¤.
# ì—¬ìê°€ ë§ë‹¤ê³  ê°€ì •í•˜ê³  í’€ì–´ì¤„ ì˜ˆì •ì´ë¼
if n > m:
    n, m = m, n
    per_n, per_m = per_m, per_n

dp = [[0] * m for _ in range(n)]    # 2ì°¨ì› dpë¡œ í’€ ì˜ˆì •
# dp[ë‚¨ì][ì—¬ì] = ë‚¨ìê°€ ì—¬ìë¥¼ ì„ íƒí–ˆì„ ë•Œ ì…©ê²© ì°¨ í•©ì˜ ìµœì†Œê°’
dp[0][0] = abs(per_n[0] - per_m[0])
for i in range(1, m-(n-1)):
    dp[0][i] = min(abs(per_n[0]-per_m[i]), dp[0][i-1])

for i in range(1, n):
    for j in range(i, m-(n-i-1)):
        if i == j:
            dp[i][j] = dp[i-1][j-1] + abs(per_n[i]-per_m[j])
        else:
            dp[i][j] = min(dp[i-1][j-1] + abs(per_n[i]-per_m[j]), dp[i][j-1])
print(dp[n-1][m-1])
```

#### ğŸ–Œ ë°±ì¤€ 17471 ê²Œë¦¬ë©˜ë”ë§
> `BFS`ë¥¼ í™œìš©í•˜ì—¬ ìµœì†Ÿê°’, ìµœëŒ“ê°’ ì„ ì •
> 1. ë‘ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ„ì–´(ì¡°í•© ì‚¬ìš©) BFSë¥¼ ì‚¬ìš©(ê° sumì„ ë„ì¶œ) 
> 2. ë‘ êµ¬ì—­ì˜ ê¸¸ì´ì˜ í•©ì´ Nìœ¼ë¡œ ê°™ì„ ê²½ìš°ì—ë§Œ ìµœì†Ÿê°’ì„ ì €ì¥í•œë‹¤. 
```python
# 17471 ê²Œë¦¬ë§¨ë”ë§
from collections import deque
from itertools import combinations

# ì„ ê±°êµ¬ ì²´í¬
def BFS(area):
    s = area[0]
    sumPop = population[s]
    Q = deque([s])
    visit = {s,}

    while Q:
        now = Q.popleft()

        for next in graph[now]:
            if next in area and next not in visit:
                sumPop += population[next]
                Q.append(next)
                visit.add(next)

    return sumPop, len(visit)

N = int(input())
population = list(map(int, input().split()))
graph = [[] for _ in range(N)]
ans = 10000

# ê·¸ë˜í”„ ì œì‘
for i in range(N):
    _, *info = list(map(int, input().split()))
    graph[i] = list(map(lambda x: x-1, info))

# ì¡°í•© ë§Œë“¤ì–´ BFS ì‹¤í–‰
for i in range(1, N//2+1):
    for area in combinations(range(N), i):
        sumA, lenA = BFS(area)
        sumB, lenB = BFS([i for i in range(N) if i not in area])

        if lenA + lenB == N:
            ans = min(ans, abs(sumA - sumB))

print(ans if ans != 10000 else -1)

``` 

#### ğŸ™ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 12906 ê°™ì€ ìˆ«ìëŠ” ì‹«ì–´
> ë°˜ë³µë¬¸ ì‚¬ìš©í•˜ì—¬ ì—°ì†ë˜ì§€ ì•ŠëŠ” ìˆ«ìëŠ” ì œì™¸

```python
def solution(arr):
    numbers = [arr[0]]
    for i in range(1,len(arr)):
        if arr[i-1] != arr[i]:
            numbers.append(arr[i])
    return numbers
```

#### ğŸ‘” í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 17680 ìºì‹œ
> ë‹¨ìˆœ ë°˜ë³µë¬¸ + ì¡°ê±´ë¬¸
> 1. result ë¦¬ìŠ¤íŠ¸ì— ê¸°ì¡´ cityê°€ ìˆìœ¼ë©´ ê°±ì‹ (1ì´ˆ ì¶”ê°€)
> 2. ì—†ë‹¤ë©´ ì¶”ê°€ (5ì´ˆ ì¦ê°€)
> 3. ìµœì¢…ì ì¸ ì‹œê°„ ë„ì¶œ

```python
from collections import deque
def solution(cacheSize, cities):
    result = []
    time= 0
    # ë„ì‹œë¥¼ ìˆœíšŒ
    for city in cities:
        # ëŒ€ë¬¸ì ì†Œë¬¸ì êµ¬ë¶„ ì—†ì–´ í•œê°€ì§€ë¡œ í†µì¼
        city = city.lower()
        # ê¸°ì¡´ì— cityê°€ ì—†ìœ¼ë©´ cityë¥¼ ì¶”ê°€
        if city not in result:
            result.append(city)
            # ë‹¤ë§Œ.. ìºì‹œì‚¬ì´ì¦ˆê°€ ì´ˆê³¼í•œë‹¤ë©´ ë§¨ ì²¨ì— ë“¤ì–´ê°„ê±°ëŠ” ë¹¼ê³ 
            if len(result) > cacheSize:
                result.pop(0)
            # ìƒˆê±°ê°€ ë“¤ì–´ê°€ë©´ ë¬´ì¡°ê±´ 5ì´ˆ ì¦ê°€
            time+=5
        # ê¸°ì¡´ì— cityê°€ ìˆë‹¤ë©´?
        else:
            # ê¸°ì¡´êº¼ë¥¼ ê°±ì‹ í•˜ê¸° ìœ„í•´ ì œê±°í•˜ê³ , ìƒˆê±° ì¶”ê°€
            result.remove(city)
            result.append(city)
            # ê¸°ì¡´ê²ƒì´ ìˆìœ¼ë©´ 1ì´ˆ ì¶”ê°€
            time+=1
    return time
```

#### â¤ï¸â€ğŸ”¥ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 64061 í¬ë ˆì¸ ì¸í˜•ë½‘ê¸° ê²Œì„ 
> 1. ì¸í˜•ë½‘ê¸°ì—ì„œ ë‚¨ì•„ìˆëŠ” ê²ƒì´ ì—†ì„ë•Œê¹Œì§€ stackì— ì¶”ê°€
> 2. stackì— ë‘ ì¸í˜•ì´ ì—°ì†ëœë‹¤ë©´ ë‘˜ë‹¤ ë¹¼ì£¼ê³  ê²°ê³¼ê°’ì— 2ì¶”ê°€
```py
def solution(board, moves):
    answer = 0
    stack = []

    for i in moves:
        for j in range(len(board)):
            if board[j][i-1] != 0:
                stack.append(board[j][i-1])
                board[j][i-1] = 0

                if len(stack) > 1:
                    if stack[-1] == stack[-2]:
                        stack.pop()
                        stack.pop()
                        answer += 2
                break

    return answer
```
#### ğŸ’• í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 67256 í‚¤íŒ¨ë“œ ëˆ„ë¥´ê¸° 
> 1. ë‘ í‚¤íŒ¨ë“œ ê°„ì˜ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” `distance` í•¨ìˆ˜ ë„ì¶œ 
> 2. í‚¤íŒ¨ë“œê°€ 147ì´ë©´ ì™¼ì†, 369ë©´ ì˜¤ë¥¸ì†, 2580ì´ë©´ ê±°ë¦¬ë¥¼ ë„ì¶œí•˜ì—¬ ê° ì†ìœ¼ë¡œë¶€í„° ê±°ë¦¬ê°€ ì‘ì€ ê³³ì„ ì„ íƒ
```py
def solution(numbers, hand):
    result =''
    # ë‘ í‚¤ë³´ë“œ ìœ„ì¹˜ê°„ì— ê°€ê¹Œìš´ ê±°ë¦¬ì˜ í‚¤íŒ¨ë“œë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
    def distance(left,right,keypad,hand):
        # ê° ê±°ë¦¬ ì¬ê¸°
        result_l = abs(keypad[1] - left[1]) + abs(keypad[0] - left[0])
        result_r = abs(keypad[1] - right[1]) + abs(keypad[0] - right[0])
        if result_l > result_r:
            return 'R'
        elif result_l < result_r:
            return 'L'
        else:
            if hand =='right':
                return 'R'
            else:
                return 'L'
    # ì²« ìŠ¤íƒ€íŠ¸ ì§€ì 
    now_l = (3,0)
    now_r = (3,2)
    # ìˆ«ìë“¤ì—ì„œ í‚¤íŒ¨ë“œ ìˆ«ìë¥¼ ëº€ë‹¤.
    for keypad in numbers:
        # í‚¤íŒ¨ë“œì— ë”°ë¥¸ ì¢Œí‘œ ì„¤ì •
        if keypad ==0:
            location = (3,1)
        else:
            location = ((keypad-1)//3,(keypad-1)%3)
        # í‚¤íŒ¨ë“œê°€ ì–´ë–¤ ìˆ«ìì„ì— ë”°ë¼ ê²°ê³¼ê°’ ì§€ì •
        if keypad in [1,4,7]:
            result+='L'
            now_l = ((keypad-1)//3,0)
        elif keypad in [3,6,9]:
            result+='R'
            now_r = ((keypad-1)//3,2)
        # ê°™ì„ ê²½ìš° í˜„ì¬ ê° ì†ìœ¼ë¡œë¶€í„° ê±°ë¦¬ë¥¼ ìŸ¤ê³  ê°€ê¹Œìš´ìª½ ì„ íƒ
        else:
            temp = distance(now_l,now_r,location,hand)
            result += temp
            if temp=='L':
                now_l = location
            elif temp=='R':
                now_r = location
    return result
```
#### ğŸ’• í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 81301 ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´
> ë”•ì…˜ë„ˆë¦¬ì™€ `replace` ì‚¬ìš©
```py
num_dic = {"zero":"0", "one":"1", "two":"2", "three":"3", "four":"4", "five":"5", "six":"6", "seven":"7", "eight":"8", "nine":"9"}

def solution(s):
    answer = s
    # ëª¨ë“  ìˆ«ìë¥¼ ìˆœíšŒí•˜ì—¬ ë³€ê²½í•˜ë©´ ë¨
    for key, value in num_dic.items():
        answer = answer.replace(key, value)
    return int(answer)
```
#### ğŸ¥ª í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 92334 ì‹ ê³  ê²°ê³¼ ë°›ê¸°
> 1. ì‹ ê³  ë‹¹í•œìë“¤ì˜ íšŸìˆ˜ë¥¼ ê¸°ë¡í•œë‹¤.
> 2. kë²ˆ ì´ìƒ ì‹ ê³  ë‹¹í–ˆìœ¼ë©´, ê·¸ì˜ ì‹ ê³ ìë“¤ì—ê²Œ ë©”ì¼ 1íšŒì”© ì¶”ê°€ ë°œì†¡í•œë‹¤.
> 3. ì²˜ìŒ ì£¼ì–´ì§„ id_listì˜ ìˆœì„œì— ë”°ë¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜í•œë‹¤.  
```py
def solution(id_list, report, k):
    answer = [0] * len(id_list)
    reports = {x:0 for x in id_list}
    # report : ì‹ ê³ ìì™€ ì‹ ê³  ë‹¹í•œì ê¸°ë¡
    for r in set(report):
        # ì‹ ê³ ìê°€ ë¶ˆëŸ‰ì´ìš©ì ì‹ ê³ í•˜ë©´ ì‹ ê³ íšŸìˆ˜ 1ì¶”ê°€
        reports[r.split()[1]] +=1

    for r in set(report):
        # kë²ˆ ì´ìƒ ì‹ ê³ ë‹¹í–ˆìœ¼ë©´
        if reports[r.split()[1]] >= k:
            # ì •ì§€íšŸìˆ˜ 1ì¶”ê°€
            answer[id_list.index(r.split()[0])] += 1
    return answer
```

#### ğŸ« í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 118666 ì„±ê²©ìœ í˜•ê²€ì‚¬í•˜ê¸°
> 1. MBTIì˜ ì •ë³´ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì •ë¦¬.
> 2. tendency_dictì— ê° ì„±í–¥ì„ ì €ì¥
> 3. ìµœì¢…ì ìœ¼ë¡œ ë§ì€ ì„±í–¥ì„ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜

```py
def solution(survey, choices):
    MBTI = ["TR","CF","MJ","AN"]
    tendency_dict = {i:0 for i in ["A","C","F","M","N","J","R","T"]}
    for i in range(len(survey)):
        left, right = survey[i]
        if choices[i] - 4 > 0:
            tendency_dict[right] += choices[i] - 4
        else:
            tendency_dict[left] += 4 - choices[i]
    result = ''
    for i,j in MBTI:
        if tendency_dict[i] > tendency_dict[j]:
            result += i
        elif tendency_dict[i] < tendency_dict[j]:
            result += j
        else:
            result += min(i,j)
    return result
```

#### ğŸ« í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 118667 ë‘ íí•© ê°™ê²Œ ë§Œë“¤ê¸°
> 1. ë‘íë¥¼ ê³„ì† ë¹„êµ. ë§¤ë²ˆ sumì„ ì“°ëŠ”ê²ƒì´ ì•„ë‹ˆë¼ ê¸°ì¡´ sumì—ì„œ ê° ìˆ«ìì˜ í•©ê³¼ ì°¨ë¥¼ ê³„ì‚°í•˜ì—¬ ê°±ì‹ 
> 2. í•œ íì—ì„œ ë‹¤ë¥¸ íë¡œ ê°ˆ ë•Œ íšŸìˆ˜ 1íšŒ ì¶”ê°€
> 3. ë‘ í í•©ì´ ê°™ì€ ê²½ìš°ê°€ ë‚˜ì˜¤ë©´ ê·¸ ë•Œì˜ count ë°˜í™˜
> 4. ë§Œì•½ ë‘ íì˜ í•©ì´ í™€ìˆ˜ê±°ë‚˜, í•œ ì›ì†Œê°€ ì „ì²´ì˜ ë°˜ì´ìƒì´ë©´ -1 ë°˜í™˜

```py
from collections import deque
def solution(queue1, queue2):
    # queue1 ê³¼ queue2
    queue1 = deque(queue1); queue2 = deque(queue2)
    q1_sum = sum(queue1);q2_sum = sum(queue2)
    n = len(queue1) + len(queue2)
    # ë‘ íì˜ í•©ì´ í™€ìˆ˜ë©´ -1 ë°˜í™˜
    if (q1_sum+ q2_sum) % 2: return -1
    count = 0
    # ë°˜ë³µ íšŸìˆ˜ê°€ ì´ ê¸¸ì´ì˜ 2ë°°ë©´ ì¤‘ë‹¨
    while queue1 and queue2 and count <= n*2:
        if q1_sum < q2_sum:
            now = queue2.popleft()
            queue1.append(now)
            q2_sum-=now;q1_sum+=now
        elif q1_sum > q2_sum:
            now = queue1.popleft()
            queue2.append(now)  
            q2_sum+=now;q1_sum-=now
        # ë‘ íì˜ í•©ì´ ë™ì¼í•˜ë©´ count ë°˜í™˜
        else:
            return count
        if now > (q1_sum + q2_sum) / 2:return -1 
        count+=1
    return -1
```
#### ğŸ« í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 150370 ê°œì¸ì •ë³´ ìˆ˜ì§‘ ìœ íš¨ê¸°ê°„
> 1. ë‚ ì§œë¥¼ ê³„ì‚°í•˜ì—¬ ë¹„êµí•˜ê¸° ìœ„í•´ termsì˜ ë‚ ì§œë¥¼ ì¼ìˆ˜ë¡œ í™˜ì‚°
> 2. privaciesì˜ ëª¨ë“  ì¼€ì´ìŠ¤ë¥¼ ìˆœíšŒí•˜ì—¬ ë³´ê´€ê¸°í•œ ë‚´ì— todayê°€ ìˆëŠ” ê²½ìš°, ë¦¬ìŠ¤íŠ¸ì˜ ì¸ë±ìŠ¤ë¥¼ ì¶”ê°€í•œë‹¤.

```py
def solution(today, terms, privacies):
    ans = []
    termsDict = {char[0]: int(char[2:]) * 28 for char in terms}
    nowY, nowM, nowD = map(int, today.split('.'))
    now = nowY * 28 * 12 + nowM * 28 + nowD

    for i in range(len(privacies)):
        pre, case = privacies[i].split()
        preY, preM, preD = map(int, pre.split('.'))
        pre = preY * 28 * 12 + preM * 28 + preD + termsDict[case]

        if pre <= now: ans.append(i+1)

    return ans
```
#### ğŸ« í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ 258712 ê°€ì¥ ë§ì´ ë°›ì€ ì„ ë¬¼
> 1. ì„ ë¬¼í•œ ì‚¬ëŒ, ë°›ì€ ì‚¬ëŒì„ ë°”íƒ•ìœ¼ë¡œ ì„ ë¬¼ì§€ìˆ˜ì™€ ê´€ê³„ë¥¼ ê³„ì‚°í•œë‹¤.
> 2. ì¤‘ë³µì—†ì´ ì¹œêµ¬ 2ëª…ì„ ìˆœíšŒí•´ì„œ, ë‘ ì‚¬ëŒ ì‚¬ì´ ì„ ë¬¼ì„ ëˆ„ê°€ ë” ë§ì´ ì¤¬ëŠ”ì§€ ê³„ì‚°í•œë‹¤.
> 3. ê¸°ë¡ì´ ì—†ê±°ë‚˜ ê°™ë‹¤ë©´ ì„ ë¬¼ì§€ìˆ˜ì— ë”°ë¼ ì¹œêµ¬ë³„ë¡œ ê°¯ìˆ˜ë¥¼ ì¶”ê°€í•œë‹¤.
```py
from itertools import combinations
def solution(friends, gifts):
    # gift_index : ì„ ë¬¼ì§€ìˆ˜
    gift_index = {i: 0 for i in friends}
    # gift_relation : ê° ì¹œêµ¬ê°€ ê° ì„ ë¬¼í•œ ì¹œêµ¬ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ êµ¬í˜„
    gift_relation = {i: {j:0 for j in friends} for i in friends}
    # ì„ ë¬¼í•œì‚¬ëŒ, ë°›ì€ì‚¬ëŒ, ê·¸ ê´€ê³„ë¥¼ ê°ê° ì €ì¥
    for person in gifts:
        gifting, gifted = person.split(' ')
        gift_index[gifting] +=1
        gift_index[gifted] -=1
        gift_relation[gifting][gifted] +=1
    # will : ì¹œêµ¬ë³„ë¡œ ì•ìœ¼ë¡œ ì„ ë¬¼ ë°›ì„ ìˆ˜ë¥¼ ì €ì¥í•¨
    will = {i:0 for i in friends}
    # ëª¨ë“  ì¹œêµ¬ ì¤‘ ë‘ëª…ì”©ì„ ì¤‘ë³µì—†ì´ ë½‘ì•„, ì„œë¡œ ì„ ë¬¼ ê¸°ë¡ì„ ë¹„êµ
    for person1,person2 in combinations(friends,2):
        if gift_relation[person1][person2] > gift_relation[person2][person1]:
            will[person1] +=1
        elif gift_relation[person1][person2] < gift_relation[person2][person1]:
            will[person2] +=1
        else:
            # ë§Œì•½ ê¸°ë¡ì´ ì—†ê±°ë‚˜ ê°™ë‹¤ë©´ ì„ ë¬¼ì§€ìˆ˜ì— ë”°ë¼ íŒì •
            if gift_index[person1] < gift_index[person2]:
                will[person2] +=1
            elif gift_index[person2] < gift_index[person1]:
                will[person1] +=1
    return max(will.values())
```