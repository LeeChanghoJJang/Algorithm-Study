## Algorithm Study 12íšŒì°¨ íšŒì˜ (24.4.21.) 

### ğŸ’¬ íšŒì˜ê°œìš”
    ê°€. ê¸ˆì¼ ì¼ì • 
        - ì‹œê°„ : 4ì›” 21ì¼ ì¼ìš”ì¼ ì•„ì¹¨ 9ì‹œ  
        - ë°©ì‹ : ë¹„ëŒ€ë©´ ë””ìŠ¤ì½”ë“œ 

    ë‚˜. ì°¨ì£¼ ì˜ˆì • ì¼ì •
        - ì‹œê°„ : 4ì›” 28ì¼ ì¼ìš”ì¼ ì €ë… 7ì‹œ  
        - ë°©ì‹ : ê¹€í•´ ì»¤í”¼íŒ€ë²„

    ë‹¤. ë³€ê²½ì‚¬í•­ ìš”ì•½ (4ì›” 28ì¼ ë¶€í„°)
        1. ê°ì ì„ ì •í•œ 1ë¬¸ì œ ë¦¬ë·°(ëª¨ë‘ ì•ì—ì„œ ë°”ë¡œ í’€ ìˆ˜ ìˆì„ ë§Œí¼) 
            - ìš”ì²­ìˆê±°ë‚˜, ë§í•˜ê³  ì‹¶ì€ ì‚¬ëŒì€ ìê¸° ë¬¸ì œ ì•„ë‹ˆë¼ë„ ì¶”ê°€ ë¦¬ë·° ê°€ëŠ¥
        2. ê°ì 1ë¬¸ì œì”©ë§Œ ì„ ì •(ì´ 7ë¬¸ì œ)
        3. ì¼ì • ê¸°ë³¸ê°’: ë§¤ì£¼ í† ìš”ì¼ 9ì‹œ ë°˜ â†’ ë§¤ì£¼ ì¼ìš”ì¼ ì €ë… 7ì‹œ
            - ì¼ì • ë³€ê²½ ì‹œ, ì‚¬ì „í˜‘ì˜í•˜ì—¬ ë³€ê²½. ë³€ê²½ë¶ˆê°€ ì‹œ ë¶ˆì°¸ë¹„ ì§€ì¶œ è¦.

### ğŸµ ë¬¸ì œ ì„ ì • ë° ë°©ì‹ 
    ê°€. ìœ í˜• :ã€ìœ í˜•ã€ ë³„ë¡œ ê°ì ë¦¬ë·°í•  ë¬¸ì œ ì„ ì • 
    ë‚˜. ë¬¸ì œìˆ˜ : ì¸ë‹¹ 1ë¬¸ì œ, ì´ 7ë¬¸ì œ
    ë‹¤. ë‚œì´ë„ : ìµœëŒ€ ë°±ì¤€ ê³¨ë“œ ì´í•˜ 
    ë¼. ì½”ë“œ ë¸Œë¦¬í•‘ && ë¦¬ë·° ë°©ì‹
      - ì´ë²ˆ ì£¼ì˜ ìƒˆë¡œìš´ ë¬¸ì œ : ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬
      - ë¬¸ì œ ì„ ì •ìê°€ í‘¼ ë°©ì‹ ë¸Œë¦¬í•‘
      - í‘¼ ë°©ì‹ ì´ì™¸ì—ë„ ë‹¤ì–‘í•œ ë°©ë²• ì œì‹œ
      - ë¬¸ì œ ì ‘ê·¼ ë°©ì‹ ìš°ì„ ìˆœìœ„ ë“± ì´ì²´ì  ì •ë¦¬

### ğŸ ì´ë²ˆíšŒì°¨ í’€ì´ ë¬¸ì œ
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 2357 ìµœì†Œê°’ê³¼ ìµœëŒ“ê°’(ê³¨ë“œ 1) - ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 1727 ì»¤í”Œë§Œë“¤ê¸°(ê³¨ë“œ 2) - DP
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 1199 ì˜¤ì¼ëŸ¬ ê²½ë¡œ(í”Œë˜í‹°ë„˜ 4) - ì˜¤ì¼ëŸ¬ ê²½ë¡œ
   ###### 4. ë™í˜„
    - ë°±ì¤€ 16946 ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸° 4(ê³¨ë“œ 2) - BFS, DFS
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 1062 ê°€ë¥´ì¹¨(ê³¨ë“œ 4) - ë°±íŠ¸ë˜í‚¹
   ###### 6. ì§€ìš°
    - ë°±ì¤€ 2638 ì¹˜ì¦ˆ(ê³¨ë“œ 3) - íƒìƒ‰ êµ¬í˜„
   ###### 7. ê¶Œë¯¼
    - ë°±ì¤€ 2533 ì‚¬íšŒë§ì„œë¹„ìŠ¤(ê³¨ë“œ 3) - íŠ¸ë¦¬ë¥¼ ì´ìš©í•œ DP

### ğŸ¤¢ ë¬¸ì œ ì„ ì •
   ###### 1. ì°½í˜¸
    - ë°±ì¤€ 1197 ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(ê³¨ë“œ 4)
    - ë°±ì¤€ 1991 íŠ¸ë¦¬ ìˆœíšŒ(ì‹¤ë²„ 1)
   ###### 2. ì˜ˆë¦¬
    - ë°±ì¤€ 2252 ì¤„ ì„¸ìš°ê¸° (ê³¨ë“œ3)
    - ë°±ì¤€ 11729 í•˜ë…¸ì´íƒ‘ ì´ë™ ìˆœì„œ (ê³¨ë“œ5)
   ###### 3. ê²½íƒœ
    - ë°±ì¤€ 1799 ë¹„ìˆ (ê³¨ë“œ1)
    - ë°±ì¤€ 17626 Four Squares (ì‹¤ë²„3)
   ###### 4. ë™í˜„
    - ë°±ì¤€ 1987 ì•ŒíŒŒë²³ (ê³¨ë“œ4)
    - ë°±ì¤€ 15903 ì¹´ë“œ í•©ì²´ ë†€ì´ (ì‹¤ë²„1)
   ###### 5. ìƒí˜„
    - ë°±ì¤€ 14427 ìˆ˜ì—´ê³¼ ì¿¼ë¦¬ 15(ê³¨ë“œ 3) - ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬
    - ë°±ì¤€ 5567 ê²°í˜¼ì‹(ì‹¤ë²„ 2)  

### ğŸ… ìŠ¤í„°ë”” ë‚´ìš© 
#### ğŸˆ ë°±ì¤€ 1197 ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬
> `Kruskal` ì´ìš©í•œ ë¬¸ì œ í’€ì´(ë³µìŠµ) 
> 1. find : ëŒ€í‘œ ë…¸ë“œ ì°¾ê¸°(ì ¤ ë£¨íŠ¸ë…¸ë“œ)
> 2. union : ë‹¤ë¥¸ ë‘ ë¬´ë¦¬ê°€ ìˆì„ ë•Œ, í•˜ë‚˜ì˜ ë¬´ë¦¬ë¡œ í•©ì³ì¤Œ(ëŒ€í‘œ ë…¸ë“œ ë™ì¼í™”)
> 3. graphë¥¼ ê°€ì¤‘ì¹˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
> 4. ìˆœíšŒí•˜ë©´ì„œ ë‹¤ë¥¸ ë¬´ë¦¬ì¼ ê²½ìš°, ëŒ€í‘œë…¸ë“œë¥¼ ë”í•˜ê³ , ê°€ì¤‘ì¹˜ë¥¼ ë”í•´ì¤Œ

```python
# ë¶€ëª¨ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜
def find(x):
    if parent[x] != x:  # ë£¨íŠ¸ ë…¸ë“œê°€ ì•„ë‹ˆë©´
        parent[x] = find(parent[x])  # ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•˜ê³  ê²½ë¡œ ì••ì¶•
    return parent[x]

# ë‘ ì§‘í•©ì„ í•©ì¹˜ëŠ” í•¨ìˆ˜
def union(x, y):
    root_x = find(x)  # xì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ìŒ
    root_y = find(y)  # yì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ìŒ
    if root_x < root_y:  # xì˜ ë£¨íŠ¸ ë…¸ë“œê°€ yì˜ ë£¨íŠ¸ ë…¸ë“œë³´ë‹¤ ì‘ìœ¼ë©´
        parent[root_y] = root_x  # yê°€ ì†í•œ ì§‘í•©ì„ xê°€ ì†í•œ ì§‘í•©ì— í¬í•¨ì‹œí‚´
    else:  # ê·¸ë ‡ì§€ ì•Šìœ¼ë©´
        parent[root_x] = root_y  # xê°€ ì†í•œ ì§‘í•©ì„ yê°€ ì†í•œ ì§‘í•©ì— í¬í•¨ì‹œí‚´

# ì…ë ¥ ë°›ê¸°
input = sys.stdin.readline
V, E = map(int, input().split())  # ì •ì ì˜ ê°œìˆ˜ì™€ ê°„ì„ ì˜ ê°œìˆ˜ ì…ë ¥
parent = list(range(V + 1))  # ê° ì •ì ì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ìê¸° ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
graph = [list(map(int, input().split()))[::-1] for i in range(E)]  # ê°„ì„  ì •ë³´ ì…ë ¥ í›„ ì—­ìˆœìœ¼ë¡œ ì €ì¥ (ê°€ì¤‘ì¹˜, ì •ì 1, ì •ì 2)
graph.sort()  # ê°€ì¤‘ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬

result = 0  # ê²°ê³¼ê°’ ì´ˆê¸°í™”
for wei, now, next in graph:  # ê°€ì¤‘ì¹˜ ìˆœì„œëŒ€ë¡œ ê°„ì„ ì„ í™•ì¸
    if find(now) != find(next):  # í˜„ì¬ ê°„ì„ ì˜ ì–‘ ë ì •ì ì´ ê°™ì€ ì§‘í•©ì— ì†í•˜ì§€ ì•Šìœ¼ë©´ (ì‚¬ì´í´ì´ ìƒì„±ë˜ì§€ ì•Šìœ¼ë©´)
        result += wei  # ê²°ê³¼ê°’ì— í˜„ì¬ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ ì¶”ê°€
        union(now, next)  # í˜„ì¬ ê°„ì„ ì˜ ì–‘ ë ì •ì ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹¨

print(result)  # ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ê°€ì¤‘ì¹˜ í•© ì¶œë ¥
```

> `Prim` ì´ìš©í•œ ë¬¸ì œ í’€ì´(ë³µìŠµ) 
> 1. linkì— ê° ê°„ì„ ì˜ ì •ë³´ë¥¼ ì–‘ë°©í–¥ìœ¼ë¡œ ì €ì¥í•œë‹¤.
> 2. `heap` êµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ ë°©ë¬¸ì•ˆí•œ ê³³ ì¤‘ ê°€ì¥ ì‘ì€ ê°€ì¤‘ì¹˜ì˜ ì •ì ì„ íƒìƒ‰í•œë‹¤.(ê·¸ë¦¬ë”” ë¡œì§)

```py
from heapq import heappush, heappop

def MST(start):
    pq = []
    heappush(pq, (0, start))
    mst = [0] * (V + 1)
    weight_sum = 0
    while pq:
        weight, now = heappop(pq)
        if mst[now]:
            continue
        mst[now] = 1
        weight_sum += weight
        for to in link[now]:
            next_w, nxt = to
            if mst[nxt]:
                continue
            else:
                heappush(pq, (next_w, nxt))
    print(weight_sum)
V, E = map(int, input().split())
link = {i: [] for i in range(1, V + 1)}
for _ in range(E):
    A, B, C = map(int, input().split())
    link[A].append([C, B])
    link[B].append([C, A])
MST(1)
```

#### ğŸ§° ë°±ì¤€ 1799 ë¹„ìˆ
> `ë°±íŠ¸ë˜í‚¹`ì„ í†µí•´ í‘¸ë‚˜, í•µì‹¬ì€ ê²€ì€íŒê³¼ í•˜ì–€íŒì„ ë‚˜ëˆ„ê¸°
> 1. ëŒ€ê°ì„  ìˆœìœ¼ë¡œ íƒìƒ‰ 
>   - diag : ê°™ì€ ëŒ€ê°ì„ (ìš°í•˜í–¥) ìƒì— ë†“ì—¬ìˆì„ ë•Œ, True í‘œì‹œ
>   - open : ì°©ìˆ˜ ê°€ëŠ¥í•œ ë¶€ë¶„(ìš°ìƒí–¥) ì¦‰, í–‰ê³¼ ì—´ì •ë³´ ì €ì¥
> 2. ê²€ì€ íŒê³¼ í•˜ì–€ íŒì„ ê° ë¹„êµí•˜ê¸° ìœ„í•´ k+2í•˜ë©´ì„œ íƒìƒ‰
```python
def BT(k, cnt):
    global ans
    # ë§ˆì§€ë§‰ ëŒ€ê°ì„ ì— ë‹¤ë‹¤ë¥´ë©´ ì¢…ë£Œ
    if k == 2*N-1:
        ans = max(ans, cnt); return

    # ê°€ì§€ì¹˜ê¸°
    if ans >= (cnt + (2*N-k)//2): return

    # ê°€ëŠ¥í•œ ë¶€ë¶„ ìˆœíšŒ
    for i, j in open[k]:
        # ì°©ìˆ˜ í›„ ë‹¤ìŒ ëŒ€ê°ì„  íƒìƒ‰
        if not diag[i-j]:
            diag[i-j] = True
            BT(k+2, cnt+1)
            diag[i-j] = False

    # ë¯¸ì°©ìˆ˜ í›„ ë‹¤ìŒ ëŒ€ê°ì„  íƒìƒ‰
    BT(k+2, cnt)

N = int(input())
grid=[list(map(int, input().split())) for _ in range(N)]
diag = [False] * (2*N-1)

# ì°©ìˆ˜ ê°€ëŠ¥í•œ ë¶€ë¶„ ì €ì¥
open = [[] for _ in range(2*N-1)]
for i in range(N):
    for j in range(N):
        if grid[i][j]:
            open[i+j].append([i, j])

# í™€ìˆ˜ë²ˆì§¸ ëŒ€ê°ì„ ê³¼ ì§ìˆ˜ë²ˆì§¸ ëŒ€ê°ì„ ì„ ë¶„ë¦¬í•˜ì—¬ ë°±íŠ¸ë˜í‚¹ ì§„í–‰
ans = 0
BT(0, 0)
BT(1, ans)
print(ans)
```
> 2. í–‰,ì—´ ìˆœìœ¼ë¡œ íƒìƒ‰
```py
import sys
import copy
input =sys.stdin.readline

# ëŒ€ê°ì„  ë°©í–¥ ì •ì˜
dr = [(1, 1), (1, -1), (-1, 1), (-1, -1)]

# ìƒ‰ê¹”ì— ë”°ë¼ ë³´ë“œì˜ ìƒ‰ì„ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
def exceptcolor(arr, color):
    for i in range(N):
        for j in range(N):
            if color == 'white':
                if (i + j) % 2 == 0:  # í°ìƒ‰ ì˜ì—­ì— ìˆëŠ” ì¹¸ì„ 0ìœ¼ë¡œ ì„¤ì •
                    arr[i][j] = 0
            if color == 'black':
                if (i + j) % 2 != 0:  # ê²€ì€ìƒ‰ ì˜ì—­ì— ìˆëŠ” ì¹¸ì„ 0ìœ¼ë¡œ ì„¤ì •
                    arr[i][j] = 0

# í•´ë‹¹ ìœ„ì¹˜ì— ë§ì„ ë†“ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
def is_possible(x, y, arr):
    for i in range(4):
        dx, dy = dr[i]
        nx, ny = x + dx, y + dy
        while 0 <= nx < N and 0 <= ny < N:
            if arr[nx][ny] == -1:  # í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ í€¸ì´ ìˆìœ¼ë©´ ë†“ì„ ìˆ˜ ì—†ìŒ
                return False
            nx += dx;ny += dy
    return True

# ë°±íŠ¸ë˜í‚¹ì„ ì´ìš©í•œ ì¬ê·€ì  íƒìƒ‰ í•¨ìˆ˜
def back(x, y, arr, cnt):
    global max_cnt

    if x >= N:
        max_cnt = max(cnt, max_cnt)  # ìµœëŒ€ í€¸ì˜ ê°œìˆ˜ ì—…ë°ì´íŠ¸
        return

    if y >= N:
        back(x + 1, 0, arr, cnt)
        return

    if arr[x][y] == 1 and is_possible(x, y, arr):
        arr[x][y] = -1  # í€¸ì„ ë†“ì€ ê³³ì„ -1ë¡œ í‘œì‹œ
        back(x, y + 1, arr, cnt + 1)  # ë‹¤ìŒ ì—´ë¡œ ì´ë™í•˜ì—¬ íƒìƒ‰ ê³„ì†
        arr[x][y] = 1  # ë°±íŠ¸ë˜í‚¹

    back(x, y + 1, arr, cnt)  # í•´ë‹¹ ì¹¸ì— í€¸ì„ ë†“ì§€ ì•Šê³  ë‹¤ìŒ ì¹¸ìœ¼ë¡œ ì´ë™í•˜ì—¬ íƒìƒ‰

# ë³´ë“œì˜ í¬ê¸° ì…ë ¥
N = int(input())

# ë³´ë“œ ìƒíƒœ ì…ë ¥
board = [list(map(int, input().split())) for i in range(N)]

white_board = copy.deepcopy(board)
black_board = copy.deepcopy(board)

exceptcolor(white_board,'black')
exceptcolor(black_board,'white')
result = 0  # ê²°ê³¼ê°’ ì´ˆê¸°í™”

# í°ìƒ‰ê³¼ ê²€ì€ìƒ‰ ì˜ì—­ì— ëŒ€í•´ ê°ê° íƒìƒ‰
for board_ in [copy.deepcopy(board), copy.deepcopy(board)]:
    max_cnt = 0  # ê° ìƒ‰ê¹”ë³„ ìµœëŒ€ í€¸ì˜ ê°œìˆ˜ ì´ˆê¸°í™”
    back(0, 0, board_, 0)  # ë°±íŠ¸ë˜í‚¹ì„ ì´ìš©í•œ íƒìƒ‰ ì‹œì‘
    result += max_cnt  # ìµœëŒ€ í€¸ì˜ ê°œìˆ˜ë¥¼ ê²°ê³¼ê°’ì— ë”í•¨

# ê²°ê³¼ ì¶œë ¥
print(result)

```
#### âš½ ë°±ì¤€ 1987 ì•ŒíŒŒë²³
> `ë°±íŠ¸ë˜í‚¹` ì´ìš©
> ê¸°ì¡´ ë°±íŠ¸ë˜í‚¹ê³¼ ë‹¤ë¥¸ ì  : visitedì˜ ë²”ìœ„ë¥¼ 26ìœ¼ë¡œ ì œí•œ(ì•ŒíŒŒë²³ ìˆ˜)

```python
# ì´ë™ ë°©í–¥ ì •ì˜ (ì•„ë˜, ì˜¤ë¥¸ìª½, ìœ„, ì™¼ìª½)
dr = [(1, 0), (0, 1), (-1, 0), (0, -1)]

# DFSë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰í•˜ëŠ” í•¨ìˆ˜
def back(x, y, visited, cnt):
    global max_cnt
    if max_cnt < cnt:  # í˜„ì¬ê¹Œì§€ì˜ ìµœëŒ€ ì¹¸ ìˆ˜ ì—…ë°ì´íŠ¸
        max_cnt = cnt

    for i in range(4):  # ë„¤ ë°©í–¥ì— ëŒ€í•´ì„œ
        nx = x + dr[i][0]
        ny = y + dr[i][1]
        if 0 <= nx < R and 0 <= ny < C and not visited[ord(arr[nx][ny]) - ord('A')]:
            # ë°°ì—´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ì•ŒíŒŒë²³ì¸ ê²½ìš°
            visited[ord(arr[nx][ny]) - ord('A')] = True  # ë°©ë¬¸ í‘œì‹œ
            back(nx, ny, visited, cnt + 1)  # DFS ì¬ê·€ í˜¸ì¶œ
            visited[ord(arr[nx][ny]) - ord('A')] = False  # ë°©ë¬¸ í•´ì œ (ë°±íŠ¸ë˜í‚¹)

# í–‰ê³¼ ì—´ì˜ ìˆ˜ ì…ë ¥
R, C = map(int, input().split())

# ë³´ë“œ ìƒíƒœ ì…ë ¥
arr = [input() for _ in range(R)]

# ì•ŒíŒŒë²³ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
visited = [False] * 26  # ì•ŒíŒŒë²³ì€ ì´ 26ê°œ

max_cnt = 0  # ìµœëŒ€ ì¹¸ ìˆ˜ ì´ˆê¸°í™”
visited[ord(arr[0][0]) - ord('A')] = True  # ì‹œì‘ ì§€ì  ì•ŒíŒŒë²³ ë°©ë¬¸ í‘œì‹œ

# DFS ì‹œì‘
back(0, 0, visited, 1)

# ê²°ê³¼ ì¶œë ¥
print(max_cnt)
```
> visited ëŒ€ì‹  memoizationì„ í™œìš©í•˜ì—¬ ìµœëŒ€ cntë¥¼ êµ¬í•¨
```py   
import sys

# ì´ë™ ë°©í–¥ ì •ì˜ (ì•„ë˜, ì˜¤ë¥¸ìª½, ìœ„, ì™¼ìª½)
dr = [(1, 0), (0, 1), (-1, 0), (0, -1)]

# DFSë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰í•˜ëŠ” í•¨ìˆ˜
def back(x, y, visited, cnt):
    global max_cnt
    if max_cnt < cnt:  # í˜„ì¬ê¹Œì§€ì˜ ìµœëŒ€ ì¹¸ ìˆ˜ ì—…ë°ì´íŠ¸
        max_cnt = cnt

    for i in range(4):  # ë„¤ ë°©í–¥ì— ëŒ€í•´ì„œ
        nx = x + dr[i][0]
        ny = y + dr[i][1]
        if 0 <= nx < R and 0 <= ny < C and not visited[ord(arr[nx][ny]) - ord('A')]:
            # ë°°ì—´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ì•ŒíŒŒë²³ì¸ ê²½ìš°
            visited[ord(arr[nx][ny]) - ord('A')] = True  # ë°©ë¬¸ í‘œì‹œ
            back(nx, ny, visited, cnt + 1)  # DFS ì¬ê·€ í˜¸ì¶œ
            visited[ord(arr[nx][ny]) - ord('A')] = False  # ë°©ë¬¸ í•´ì œ (ë°±íŠ¸ë˜í‚¹)

# í–‰ê³¼ ì—´ì˜ ìˆ˜ ì…ë ¥
R, C = map(int, input().split())

# ë³´ë“œ ìƒíƒœ ì…ë ¥
arr = [input() for _ in range(R)]

# ì•ŒíŒŒë²³ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
visited = [False] * 26  # ì•ŒíŒŒë²³ì€ ì´ 26ê°œ

max_cnt = 0  # ìµœëŒ€ ì¹¸ ìˆ˜ ì´ˆê¸°í™”
visited[ord(arr[0][0]) - ord('A')] = True  # ì‹œì‘ ì§€ì  ì•ŒíŒŒë²³ ë°©ë¬¸ í‘œì‹œ

# DFS ì‹œì‘
back(0, 0, visited, 1)

# ê²°ê³¼ ì¶œë ¥
print(max_cnt)
```

#### ğŸ–Œ ë°±ì¤€ 1991 íŠ¸ë¦¬ ìˆœíšŒ 
> ì „ìœ„, ì¤‘ìœ„, í›„ìœ„ ìˆœíšŒë¥¼ ê°ê° ì •ì˜í•˜ëŠ”ë° `ì¬ê·€`ë¡œ êµ¬í˜„

```python
import sys

# í‘œì¤€ ì…ë ¥ì„ 'input.txt'ì—ì„œ ì½ë„ë¡ ì¬ì§€ì •
sys.stdin = open('input.txt')

# íŠ¸ë¦¬ì˜ ë…¸ë“œ ìˆ˜ ì…ë ¥
N = int(input())

# ì „ìœ„ ìˆœíšŒ í•¨ìˆ˜
def preorder(now):
    if trees.get(now):  # í˜„ì¬ ë…¸ë“œì— ìì‹ì´ ìˆëŠ” ê²½ìš°
        print(now, end='')  # í˜„ì¬ ë…¸ë“œ ì¶œë ¥
        preorder(trees[now][0])  # ì™¼ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ
        preorder(trees[now][1])  # ì˜¤ë¥¸ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ

# ì¤‘ìœ„ ìˆœíšŒ í•¨ìˆ˜
def inorder(now):
    if trees.get(now):  # í˜„ì¬ ë…¸ë“œì— ìì‹ì´ ìˆëŠ” ê²½ìš°
        inorder(trees[now][0])  # ì™¼ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ
        print(now, end='')  # í˜„ì¬ ë…¸ë“œ ì¶œë ¥
        inorder(trees[now][1])  # ì˜¤ë¥¸ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ

# í›„ìœ„ ìˆœíšŒ í•¨ìˆ˜
def postorder(now):
    if trees.get(now):  # í˜„ì¬ ë…¸ë“œì— ìì‹ì´ ìˆëŠ” ê²½ìš°
        postorder(trees[now][0])  # ì™¼ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ
        postorder(trees[now][1])  # ì˜¤ë¥¸ìª½ ìì‹ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê·€ í˜¸ì¶œ
        print(now, end='')  # í˜„ì¬ ë…¸ë“œ ì¶œë ¥

# íŠ¸ë¦¬ êµ¬ì„±
trees = {}
for i in range(N):
    now, left, right = input().split()
    trees[now] = [left, right]

# ì „ìœ„ ìˆœíšŒ ì¶œë ¥
preorder('A')
print()
# ì¤‘ìœ„ ìˆœíšŒ ì¶œë ¥
inorder('A')
print()
# í›„ìœ„ ìˆœíšŒ ì¶œë ¥
postorder('A')

``` 

#### ğŸ™ ë°±ì¤€ 2252 ì¤„ ì„¸ìš°ê¸°
> ì²«ë²ˆì§¸, `ìœ„ìƒì •ë ¬`ì„ ì´ìš©(ë‹¨ë°©í–¥ ê·¸ë˜í”„)
> 1. ì—°ê²°ì •ë³´ë¥¼ `ì—°ê²°ë¦¬ìŠ¤íŠ¸` í˜•íƒœë¡œ ë‹´ëŠ”ë‹¤(ë”•ì…”ë„ˆë¦¬ì— ê°’ì´ ë¦¬ìŠ¤íŠ¸ì¸ í˜•íƒœ)
> 2. ê·¸ë˜í”„ë¥¼ ì—°ê²°ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê° ì§„ì…ì°¨ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤.
> 3. ì§„ì…ì°¨ìˆ˜ê°€ 0ì¸ê²ƒë¶€í„° queueì— ì´ˆê¸°ê°’ìœ¼ë¡œ ë‹´ëŠ”ë‹¤.
> 4. ê° íë¥¼ ìˆœíšŒí•˜ë©´ì„œ ì—°ê²°ëœ ê³³ì˜ ì§„ì…ì°¨ìˆ˜ë¥¼ í•˜ë‚˜ì”© ê¹ëŠ”ë‹¤.
> 5. ê·¸ ë‹¤ìŒ ì§„ì…ì°¨ìˆ˜ê°€ 0ì¸ ê²ƒì„ ìˆœíšŒí•˜ë©´ì„œ ì •ë ¬í•œ ì •ë³´ë¥¼ resultì— ë‹´ëŠ”ë‹¤.

```python
from collections import defaultdict, deque
def topological_sort(graph):
    # ì§„ì… ì°¨ìˆ˜ ê³„ì‚°
    in_degree = defaultdict(int)
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] += 1
    # ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ íì— ì‚½ì…
    queue = deque([node for node in graph if in_degree[node] == 0])
    # ê²°ê³¼ë¥¼ ë‹´ì„ ë¦¬ìŠ¤íŠ¸
    result = []
    # íê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ
    while queue:
        # íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ ê²°ê³¼ì— ì¶”ê°€
        node = queue.popleft()
        result.append(node)
        # í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œì˜ ì§„ì… ì°¨ìˆ˜ë¥¼ ê°ì†Œì‹œí‚¤ê³ , 0ì´ ë˜ë©´ íì— ì¶”ê°€
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    # ì‚¬ì´í´ì´ ìˆëŠ” ê²½ìš°ì—ëŠ” ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ì§€ ëª»í•˜ë¯€ë¡œ None ë°˜í™˜
    if len(result) != len(graph):
        return None
    return result

# ê·¸ë˜í”„ ì •ì˜ (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœ)
N,M = map(int,input().split())
graph = {i: [] for i in range(1,N+1)}
for i in range(M):
    A,B = map(int,input().split())
    graph[A].append(B)

# ìœ„ìƒ ì •ë ¬ ìˆ˜í–‰
result = topological_sort(graph)
print(*result)
```
> ë‘ë²ˆì§¸, `DFS` í™œìš©
> 1. ê·¸ë˜í”„ë¥¼ ë‹¨ë°©í–¥ìœ¼ë¡œ ì œì‘
> 2.  `DFS`ë¥¼ í†µí•´ stackì— ìŒ“ëŠ”ë‹¤.
> 3. stackì—ì„œ ì—­ìˆœìœ¼ë¡œ ì¡°íšŒí•œë‹¤. 
```py
N, M = map(int, input().split())
graph = [[] for _ in range(N+1)]
visit = [False] * (N+1)
stack = []

# ê·¸ë˜í”„ ì œì‘
for _ in range(M):
    f, b = map(int, input().split())
    graph[f].append(b)

def DFS(now):
    visit[now] = True
    # ê·¸ë˜í”„ ìˆœíšŒ
    for next in graph[now]:
        if not visit[next]:
            DFS(next)
    # ì œì¼ ìš°ì„ ìˆœìœ„ê°€ ë‚®ì€ ê²ƒë¶€í„° ìŠ¤íƒì— ì €ì¥
    stack.append(now)

# ê° ë²ˆí˜¸ ìˆœíšŒí•˜ë©° ë°©ë¬¸í•˜ì§€ ì•Šì•˜ìœ¼ë©´ DFS ê°€ë™
for i in range(1, N+1):
    if not visit[i]: DFS(i)

# ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ê²ƒë¶€í„° ì¶œë ¥
while stack:
    print(stack.pop(), end=' ')
```

#### ğŸ‘” ë°±ì¤€ 5567 ê²°í˜¼ì‹
> `depth`ê°€ 2ì¸ `BFS` êµ¬í˜„
```python
from collections import deque

n = int(input())
m = int(input())

graph = [[] for _ in range(n+1)]
dist = [1, 1] + [0] * (n-1)
Q = deque([1])
cnt = 0

# ê·¸ë˜í”„ ì œì‘
for i in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# ë„ˆë¹„ìš°ì„ íƒìƒ‰
while Q:
    now = Q.popleft()

    # ì¹œêµ¬ì˜ ì¹œêµ¬ê¹Œì§€ë§Œ í—ˆìš©
    if dist[now] == 3:
        continue

    # ê·¸ë˜í”„ ìˆœíšŒ
    for next in graph[now]:
        if not dist[next]:
            dist[next] = dist[now] + 1
            Q.append(next)
            cnt += 1

print(cnt)
```
> ë‘ë²ˆì§¸ ë°©ë²• : `ì¤‘ì²©ë°˜ë³µë¬¸` í™œìš©
> 1. ì–‘ë°©í–¥ ê·¸ë˜í”„ë¡œ ì¹œêµ¬ ê´€ê³„ í˜•ì„±
> 2. ìˆœì°¨ì ìœ¼ë¡œ ë°©ë¬¸í•œ ê³³ì„ ì²´í¬í•˜ë©´ì„œ ì¹œêµ¬ì™€ ì¹œêµ¬ì˜ ì¹œêµ¬ ì°¾ê¸°
> 3. ì „ì²´ ê¸¸ì´ì—ì„œ ë³¸ì¸ì„ ì œì™¸í•œ ì¹œêµ¬ë“¤ ê°¯ìˆ˜ ì¶œë ¥
```py
n = int(input())
m = int(input())
visited = [0, 1] + [0] * (n-1)
graph = [[] for _ in range(n+1)]
for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# ì¹œêµ¬ ì°¾ê¸°
for i in graph[1]:
    if not visited[i]:
        visited[i] = 1
    
    # ì¹œêµ¬ì˜ ì¹œêµ¬ ì°¾ê¸°
    for j in graph[i]:
        if not visited[j]:
            visited[j] = 1

print(sum(visited)-1)
``` 
---
#### ğŸ“€ ë°±ì¤€ 11729 í•˜ë…¸ì´íƒ‘ ì´ë™ ìˆœì„œ
> ëª©í‘œ : nê°œì˜ ì›íŒì„ A ì—ì„œ Cë¡œ ì˜®ê¸°ëŠ” ê²ƒì´ ëª©í‘œ
> 1. A : n-1ê°œì˜ ì›íŒ â†’ Bë¡œ ì˜®ê¹€ (A : 1ê°œ / B: n-1ê°œ / C: 0ê°œ)
> 2. A : 1ê°œì˜ ì›íŒ(ì ¤ í° ì›íŒ) â†’ Cë¡œ ì˜®ê¹€ (A : 0ê°œ / B: n-1ê°œ / C: 1ê°œ)
> 3. B : n-1ê°œì˜ ì›íŒ â†’ Cë¡œ ì˜®ê¹€ (A : 0ê°œ / B: 0ê°œ / C : nê°œ)
>   > â†’ n-1ê°œë¥¼ 1ê°œë¡œ ì¹˜í™˜í•˜ë©´ ì‰½ê²Œ ìƒê°í•  ìˆ˜ ìˆìŒ.
>   > â†’ nê°œë¶€í„° ì‹œì‘í–ˆì„ ë•Œ, ì¬ê·€í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ë©´ n-1, n-2 ... 1ê°œê¹Œì§€ ë‚´ë ¤ì™€ì„œ ì´ë™ì„ í•˜ê²Œ ë¨

```python
# í•˜ë…¸ì´ íƒ‘ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì¬ê·€ í•¨ìˆ˜
def hanoi(n, start, end):
    # ê¸°ë³¸ ê²½ìš°: ë””ìŠ¤í¬ê°€ í•˜ë‚˜ë§Œ ìˆëŠ” ê²½ìš°, ì‹œì‘ ê¸°ë‘¥ì—ì„œ ë ê¸°ë‘¥ìœ¼ë¡œ ì´ë™
    if n == 1:
        print(start, end)  # ì‹œì‘ ê¸°ë‘¥ì—ì„œ ë ê¸°ë‘¥ìœ¼ë¡œ ë””ìŠ¤í¬ ì´ë™
        return

    # ì‹œì‘ ê¸°ë‘¥ì—ì„œ ë‚¨ì€ n-1ê°œì˜ ë””ìŠ¤í¬ë¥¼ ë³´ì¡° ê¸°ë‘¥ìœ¼ë¡œ ì´ë™
    hanoi(n - 1, start, 6 - start - end)

    # ì‹œì‘ ê¸°ë‘¥ì—ì„œ ê°€ì¥ í° ë””ìŠ¤í¬ë¥¼ ë ê¸°ë‘¥ìœ¼ë¡œ ì´ë™
    print(start, end)

    # ë³´ì¡° ê¸°ë‘¥ì—ì„œ ë‚¨ì€ n-1ê°œì˜ ë””ìŠ¤í¬ë¥¼ ë ê¸°ë‘¥ìœ¼ë¡œ ì´ë™
    hanoi(n - 1, 6 - start - end, end)

# í‘œì¤€ ì…ë ¥ì—ì„œ ë””ìŠ¤í¬ì˜ ê°œìˆ˜ë¥¼ ì½ìŒ
n = int(input())

# ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° í•„ìš”í•œ ì´ ì´ë™ íšŸìˆ˜ë¥¼ ê³„ì‚°í•˜ê³  ì¶œë ¥
print(2 ** n - 1)

# í•˜ë…¸ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ í•˜ë…¸ì´ íƒ‘ ë¬¸ì œë¥¼ í•´ê²°
hanoi(n, 1, 3)

```

#### ğŸ§â€â™€ï¸ ë°±ì¤€ 14427 ìˆ˜ì—´ê³¼ ì¿¼ë¦¬ 15
> `ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬` í™œìš©
> 1. ì´ì§„ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ ê° ì´ˆê¸°ê°’ì„ ì„¤ì •í•œë‹¤.
>   - inití•¨ìˆ˜ëŠ” ë¦¬í”„ë…¸ë“œì¼ ê²½ìš°ì—ëŠ” ê·¸ ì¸ë±ìŠ¤ì— ë§¤ì¹­ë˜ëŠ” ìˆ˜ ìì²´ë¥¼ ë°˜í™˜í•œë‹¤.
>   - ì ì°¨ ì˜¬ë¼ê°€ë©´ì„œ ë‘ ìì‹ë…¸ë“œ ê°„ì˜ ìµœì†Œê°’ì„ ë¶€ëª¨ë…¸ë“œì— ì €ì¥í•œë‹¤.
> 2. ê°’ì„ ê°±ì‹ í•˜ë©´ ê·¸ ë…¸ë“œë¶€í„° ë¶€ëª¨ë…¸ë“œì— ì´ë¥´ê¸°ê¹Œì§€ ì˜í–¥ì„ ë¯¸ì¹˜ê¸° ë•Œë¬¸ì— ì „ë¶€ ë³€ê²½ì´ í•„ìš”
> ex) 5 4 3 2 1ì— init í•¨ìˆ˜ ì‹¤í–‰ì‹œ treeëŠ”
> [0, [1, 5], [3, 3], [1, 5], [4, 2], [3, 3], [2, 4], [1, 5], [5, 1], [4, 2], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
> 3. ìµœì†Ÿê°’ì„ ì°¾ëŠ” í•¨ìˆ˜ëŠ” find_min í•¨ìˆ˜ì´ë©°, íŠ¸ë¦¬ ë‚´ì˜ ìµœì†Œê°’ì„ ë°˜í™˜í•œë‹¤.
> 4. updateí•¨ìˆ˜ëŠ” í˜„ì¬ ë…¸ë“œë¶€í„° ë£¨íŠ¸ë…¸ë“œê¹Œì§€ ê°±ì‹ í• ê°’ ì¸ë±ìŠ¤ì™€ ìƒˆê°’ì„ ë„£ìœ¼ë©´ ê·¸ë ‡ê²Œ ê°±ì‹ 

```python
 Segment Tree ì´ˆê¸°í™” í•¨ìˆ˜
def init(start, end, index):
    # ë§Œì•½ ì‹œì‘ê³¼ ëì´ ê°™ìœ¼ë©´ í•´ë‹¹ ìœ„ì¹˜ì˜ ê°’ì„ íŠ¸ë¦¬ì— ì €ì¥
    if start == end:
        tree[index] = arr[start]
    else:
        mid = (start + end) // 2
        # ì¢Œì¸¡ê³¼ ìš°ì¸¡ ìì‹ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ì¬ê·€ì ìœ¼ë¡œ íŠ¸ë¦¬ë¥¼ ì±„ì›€
        tree[index] = min(init(start, mid, index * 2), init(mid + 1, end, index * 2 + 1))
    return tree[index]

# ê°’ ê°±ì‹  í•¨ìˆ˜
def update(start, end, index, w, v):
    # ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°ì—ëŠ” ì¢…ë£Œ
    if w < start or w > end:
        return
    # ë¦¬í”„ ë…¸ë“œì— ë„ë‹¬í•œ ê²½ìš°
    if start == end:
        tree[index] = v
        return tree[index]
    mid = (start + end) // 2
    # ì¢Œì¸¡ê³¼ ìš°ì¸¡ ìì‹ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ê°±ì‹  ëŒ€ìƒì´ ìˆëŠ” ìª½ì„ ì„ íƒí•˜ì—¬ ì¬ê·€ í˜¸ì¶œ
    update(start, mid, index * 2, w, v)
    update(mid + 1, end, index * 2 + 1, w, v)
    # ê°±ì‹ ëœ ìì‹ ë…¸ë“œë“¤ ì¤‘ì—ì„œ ìµœì†Œê°’ì„ ë¶€ëª¨ ë…¸ë“œì— ì €ì¥
    tree[index] = min(tree[index * 2], tree[index * 2 + 1])

# ìµœì†Œê°’ ì°¾ê¸° í•¨ìˆ˜
def find_min(start, end, index, left, right):
    # ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° ìµœëŒ€ê°’ ë°˜í™˜
    if start > right or end < left:
        return [sys.maxsize, sys.maxsize]
    # ë²”ìœ„ê°€ ì™„ì „íˆ ì†í•˜ëŠ” ê²½ìš° í˜„ì¬ ë…¸ë“œì˜ ê°’ì„ ë°˜í™˜
    if start >= left and end <= right:
        return tree[index]
    mid = (start + end) // 2
    # ì¢Œì¸¡ê³¼ ìš°ì¸¡ ìì‹ìœ¼ë¡œ ë¶„í• í•˜ì—¬ ìµœì†Œê°’ì„ ì°¾ìŒ
    return min(find_min(start, mid, index * 2, left, right), find_min(mid + 1, end, index * 2 + 1, left, right))

# ì…ë ¥ ë°›ê¸°
N = int(input())
tmp = list(map(int, input().split()))
arr = []
for i in range(N):
    # (ê°’, ì¸ë±ìŠ¤) í˜•íƒœë¡œ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥
    arr.append([tmp[i], i + 1])
tree = [0] * (N * 4)

# Segment Tree ì´ˆê¸°í™”
init(0, N - 1, 1)
print(tree)
# ì¿¼ë¦¬ ì²˜ë¦¬
for j in range(int(input())):
    tmp = list(map(int, input().split()))
    if tmp[0] == 2:
        # 2ë²ˆ ì¿¼ë¦¬ì¸ ê²½ìš° ìµœì†Œê°’ ì¶œë ¥
        print(find_min(0, N - 1, 1, 0, N - 1)[1])
    elif tmp[0] == 1:
        # 1ë²ˆ ì¿¼ë¦¬ì¸ ê²½ìš° ê°’ ê°±ì‹  ë° íŠ¸ë¦¬ ì¬êµ¬ì„±
        arr[tmp[1] - 1][0] = tmp[2]
        update(0, N - 1, 1, tmp[1] - 1, arr[tmp[1] - 1])

```
> `heap`ì˜ ìš°ì„ ìˆœìœ„ íë¥¼ í™œìš©í•œ ë¬¸ì œí’€ì´
> 1. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì™€ ë™ì¼í•˜ê²Œ (ê°’, ì¸ë±ìŠ¤) íŠœí”Œì„ í™ì— ì €ì¥í•œë‹¤.
> 2. ì¿¼ë¦¬ë²ˆí˜¸ë¥¼ ë°›ëŠ”ë‹¤.
>   > 1ì¸ ê²½ìš°, í•´ë‹¹ ì¸ë±ìŠ¤ì™€ ê°±ì‹ í•  ê°’ì„ í™ì— ì¶”ê°€í•œë‹¤.
>   > - ê·¸ëŸ° ê²½ìš°ì— ê°™ì€ ì¸ë±ìŠ¤ì— ê°’ì´ ë‘ ê°œ ì´ìƒì´ ëœë‹¤.
>   > 2ì¸ ê²½ìš°, `heappop`ë©”ì„œë“œë¥¼ í†µí•´ ìµœì†Œê°’ì„ ì¶œë ¥í•œë‹¤.
>   > - listì™€ ë¹„êµí•˜ì—¬ ì° ìµœì†Œê°’ì´ ë§ëŠ”ì§€ í™•ì¸í•œë‹¤. ë§ìœ¼ë©´ ì¶œë ¥í•œë‹¤.
```py
from heapq import *  # heapq ëª¨ë“ˆ import

N = int(input())  # ë°°ì—´ì˜ ê¸¸ì´ ì…ë ¥
list_ = list(map(int, input().split()))  # ë°°ì—´ ì…ë ¥
M = int(input())  # ì¿¼ë¦¬ ê°œìˆ˜ ì…ë ¥

q = [(list_[i], i) for i in range(N)]  # (ê°’, ì¸ë±ìŠ¤) íŠœí”Œì„ í™ì— ì €ì¥
heapify(q)  # í™ ì†ì„± ìœ ì§€

for _ in range(M):  # ì¿¼ë¦¬ ê°œìˆ˜ë§Œí¼ ë°˜ë³µ
    query, *temp = list(map(int, input().split()))  # ì¿¼ë¦¬ ì…ë ¥

    if query == 1:  # ì¿¼ë¦¬ê°€ 1ì¸ ê²½ìš°
        list_[temp[0] - 1] = temp[1]  # ë°°ì—´ì˜ í•´ë‹¹ ì¸ë±ìŠ¤ ê°’ì„ ê°±ì‹ 
        heappush(q, (temp[1], temp[0] - 1))  # í™ì— ìƒˆë¡œìš´ ê°’ì„ ì¶”ê°€
    else:  # ì¿¼ë¦¬ê°€ 2ì¸ ê²½ìš°
        while list_[q[0][1]] != q[0][0]:  # ìµœì†Ÿê°’ì´ ë°°ì—´ì— ìˆëŠ”ì§€ í™•ì¸
            heappop(q)  # ìµœì†Ÿê°’ì´ ë°°ì—´ì— ì—†ìœ¼ë©´ í™ì—ì„œ ì œê±°

        print(q[0][1] + 1)  # ìµœì†Ÿê°’ì˜ ì¸ë±ìŠ¤ ì¶œë ¥

```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 15903 ì¹´ë“œ í•©ì²´ ë†€ì´
> `heap`ì„ í™œìš©í•˜ì—¬ ìµœì†Œê°’ ë‘ê°œë¥¼ ë”í•´ì„œ ë‹¤ì‹œ heappushë¡œ ë„£ì–´ì¤Œ
```python
# ì…ë ¥ ë°›ê¸°
n, m = map(int, input().split())  # ì¹´ë“œì˜ ê°œìˆ˜ì™€ í•©ì²´ ì—°ì‚°ì˜ ìˆ˜ ì…ë ¥
heap = list(map(int, input().split()))  # ì¹´ë“œì˜ ê°€ì¹˜ ì…ë ¥
heapify(heap)  # ì¹´ë“œì˜ ê°€ì¹˜ë¥¼ ìµœì†Œ í™ìœ¼ë¡œ ë³€í™˜

# í•©ì²´ ì—°ì‚° ìˆ˜í–‰
for i in range(m):
    a = heappop(heap)  # ê°€ì¥ ê°€ì¹˜ê°€ ì‘ì€ ì¹´ë“œ êº¼ë‚´ê¸°
    b = heappop(heap)  # ë‘ ë²ˆì§¸ë¡œ ê°€ì¹˜ê°€ ì‘ì€ ì¹´ë“œ êº¼ë‚´ê¸°
    heappush(heap, a + b)  # ë‘ ì¹´ë“œë¥¼ í•©ì¹œ ê°€ì¹˜ë¥¼ ë‹¤ì‹œ ìµœì†Œ í™ì— ì¶”ê°€
    heappush(heap, a + b)  # í•©ì¹œ ê²°ê³¼ë¥¼ ë‹¤ì‹œ ìµœì†Œ í™ì— ì¶”ê°€í•˜ì—¬ ì¤‘ë³µí•´ì„œ ë”í•  ìˆ˜ ìˆë„ë¡ í•¨

# ìµœì¢… ê²°ê³¼ ì¶œë ¥
print(sum(heap))  # í•©ì²´ ì—°ì‚°ì„ ëª¨ë‘ ìˆ˜í–‰í•œ í›„ ì¹´ë“œë“¤ì˜ ê°€ì¹˜ì˜ í•© ì¶œë ¥
```

#### â¤ï¸â€ğŸ”¥ ë°±ì¤€ 17626 Four Squares
> `DP` ë¬¸ì œì¸ë“¯ í•˜ë©´ì„œ ë¸Œë£¨íŠ¸í¬ìŠ¤ ë¬¸ì œ
> íšŸìˆ˜ë¥¼ ì¤„ì´ëŠ” ê²ƒì´ ê´€ê±´
```py
n = int(input())

# ì œê³± ìˆ˜ëŠ” 1ë¡œ ë°°ì—´ì— ì €ì¥
DP = [4 if i**0.5%1 else 1 for i in range(n+1)]

# ì œê³± ìˆ˜ì´ë©´ íŒ¨ìŠ¤
if DP[n] == 1: exit(print(1))

# ë°°ì—´ ìˆœíšŒ
for i in range(1, n+1):
    # ìµœëŒ€ ì œê³±ê·¼ê¹Œì§€ ìˆœíšŒ
    for j in range(1, int(i**0.5)+1):
        # ìµœì†Œ íšŸìˆ˜ ì €ì¥
        DP[i] = min(DP[i], DP[i-j**2] + 1)

print(DP[n])
```
