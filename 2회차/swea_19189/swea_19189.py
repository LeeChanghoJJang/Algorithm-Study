# swea 19189 순열의 아름다움
'''
P=[6,7,1,8,3,2,5,4]
(1,2),(5,8),(7,8),(3,3) 등은 이 순열에 존재하는 아름다운 쌍의 개수
길이 N의 모든 순열에 대해 아름다운 쌍의 개수의 합을
소수 P로 나눈 나머지는?

P1, P2, ...,PN에 대해
max(Pl,...,Pr) - min(Pl,...Pr) = r-l

순열 갯수 *
N = 1이면
r - l = 0 ---> 순열 1개만 존재

N = 2이면 ...
r - l = 1 --> 순열 2개 존재 2! (순열의 갯수) * 2(순서쌍의 개수)
순열   [1,2] [2,1]
순서쌍  (1,2)

r - l = 0 --> 순열 4개 존재 2! (순열의 갯수) * 2(순서쌍의 개수)
순열   [1,2] [2,1] [1,2] [2,1]
순서쌍 [1,1] [1,1] [2,2] [2,2]

N = 3이면
r - l = 0 --> 순열 18개 존재 3!(순열의 갯수) * 3(순서쌍의 개수) = 18
r - l = 1 --> 순열 8개 존재  ??? = 8
[1,2,3] [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] [3,2,1]
(1,2)   (2,3)   (2,3)    (1,2)   (1,2)  (2,3)    (1,2)   (2,3)

r - l = 2 --> 순열 6개 존재  3!
[1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]
(1,3)   (1,3)    (1,3)   (1,3)   (1,3)   (1,3)

N = 4이면
r - l = 0 --> 순열 64개 존재 4!(순열의 갯수) * 4(순서쌍의 개수) = 64
r - l = 1 --> 순열 36개 존재
1234 3개
1243 2개
1324 1개
1342 1개
1423 1개
1432 2개
2134 2개
2143 2개
2314 1개
2341 2개
2413 0개
2431 1개
3124 1개
3142 0개
3214 2개
3241 1개
3412 2개
3421 2개
4123 2개
4132 1개
4213 1개
4231 1개
4312 2개
4321 3개
r - l = 2 --> 순열 24개 존재?
1234 2개
1243 1개
1324 2개
1342 1개
1423 1개
1432 1개
2134 1개
2143 0개
2314 1개
2341 1개
2413 0개
2431 1개
3124 1개
3142 0개
3214 1개
3241 1개
3412 0개
3421 1개
4123 1개
4132 1개
4213 1개
4231 2개
4312 1개
4321 2개


N    0       1         2      3
0
1    0      1!
2    0      2!*2    2!
3    0      3!*3    2!*2*2    3!
4    0      4!*4    3!*3*2    2!*2*2*3   4!
5    0      5!*5    4!*4*2    3!*3*2*3   2!*2*2*3*4  5!
이렇게 되지 않을까??
DP[N] = N!*N + (N-1)!*(N-1)*2 +(N-2)!*(N-2)*3 +...
'''
import sys
sys.stdin = open('input.txt')
T = int(sys.stdin.readline().strip())

def solve(N, P, factorials):
    result = 0
    current_factorial = 1
    for i in range(N,0,-1):
        current_factorial = (current_factorial * (N-i+1))%P
        result = (result + factorials[i] * i* current_factorial) % P
    return result

for tc in range(1, T + 1):
    N, P = map(int, sys.stdin.readline().split())
    factorials = [1] * 250001
    # 미리 팩토리얼을 계산하여 저장
    for i in range(1, 250001):
        factorials[i] = (factorials[i - 1] * i) % P
    result = solve(N, P, factorials)
    print(f'#{tc} {result}')

# 내가 썻던 코드 : 런타임 오류(시간 초과)
# T = int(input())
# for tc in range(1,T+1):
#     N, P = map(int,input().split())
#
#     # DP정의
#     DP = [[0, (math.factorial(i) * i) % P] + [0] * (N - 1) for i in range(N + 1)]
#     for j in range(2, N + 1):
#         for i in range(j, N + 1):
#             DP[i][j] = (DP[i - 1][j - 1] * j) % P
#
#     print(f'#{tc} {sum(DP[N])%P}')
